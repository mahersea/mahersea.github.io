<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Aurora Plasma Screensaver</title>
  <meta name="description" content="Mesmerizing aurora borealis and plasma effects screensaver with flowing colors">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: #000510;
      overflow: hidden;
      font-family: 'Arial', sans-serif;
      cursor: none;
    }
    
    canvas {
      display: block;
      background: radial-gradient(ellipse at center, #001122 0%, #000000 100%);
    }
    
    .controls {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 100;
      background: rgba(0, 0, 20, 0.7);
      padding: 15px;
      border-radius: 10px;
      border: 1px solid rgba(100, 200, 255, 0.3);
      color: #88ccff;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.3s;
      backdrop-filter: blur(10px);
    }
    
    .controls:hover {
      opacity: 1;
    }
    
    .controls::before {
      content: "✨";
      position: absolute;
      top: -5px;
      right: -5px;
      font-size: 16px;
    }
    
    .control-row {
      margin: 8px 0;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    label {
      min-width: 70px;
      color: #66aaff;
    }
    
    input[type="range"] {
      background: transparent;
      accent-color: #44aaff;
      width: 80px;
    }
    
    .value {
      color: #88ffaa;
      font-weight: bold;
      min-width: 25px;
      text-align: right;
    }
    
    .preset-btn {
      background: linear-gradient(135deg, #2244aa, #4488cc);
      color: white;
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 10px;
      margin: 2px;
      transition: all 0.2s;
    }
    
    .preset-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 8px rgba(100, 200, 255, 0.5);
    }
    
    .info {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: rgba(255, 255, 255, 0.3);
      font-size: 10px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <div class="controls">
    <div class="control-row">
      <label>Speed:</label>
      <input type="range" id="speed" min="0.1" max="3" value="1" step="0.1">
      <span class="value" id="speedValue">1.0</span>
    </div>
    <div class="control-row">
      <label>Intensity:</label>
      <input type="range" id="intensity" min="0.3" max="2" value="1" step="0.1">
      <span class="value" id="intensityValue">1.0</span>
    </div>
    <div class="control-row">
      <label>Waves:</label>
      <input type="range" id="waves" min="2" max="8" value="4">
      <span class="value" id="wavesValue">4</span>
    </div>
    <div class="control-row">
      <label>Flow:</label>
      <input type="range" id="flow" min="0.1" max="2" value="0.8" step="0.1">
      <span class="value" id="flowValue">0.8</span>
    </div>
    <div style="margin-top: 10px; text-align: center;">
      <button class="preset-btn" onclick="setPreset('aurora')">Aurora</button>
      <button class="preset-btn" onclick="setPreset('plasma')">Plasma</button>
      <button class="preset-btn" onclick="setPreset('ocean')">Ocean</button>
      <button class="preset-btn" onclick="setPreset('fire')">Fire</button>
    </div>
  </div>
  
  <div class="info">
    Move mouse to show controls • Press F11 for fullscreen
  </div>
  
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Fullscreen canvas
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Animation parameters
    let animationSpeed = 4.0;
    let intensity = 1.0;
    let waveCount = 1;
    let flowSpeed = .8;
    let time = 0;
    
    // Color presets
    const colorPresets = {
      aurora: {
        primary: [0, 255, 150],    // Green
        secondary: [150, 100, 255], // Purple
        accent: [255, 200, 100],    // Warm yellow
        background: [0, 50, 100]    // Deep blue
      },
      plasma: {
        primary: [255, 0, 150],     // Magenta
        secondary: [0, 150, 255],   // Cyan
        accent: [255, 255, 0],      // Yellow
        background: [50, 0, 100]    // Purple
      },
      ocean: {
        primary: [0, 200, 255],     // Bright blue
        secondary: [0, 255, 200],   // Cyan
        accent: [100, 255, 255],    // Light cyan
        background: [0, 20, 80]     // Deep blue
      },
      fire: {
        primary: [255, 100, 0],     // Orange
        secondary: [255, 0, 100],   // Red-pink
        accent: [255, 255, 100],    // Yellow
        background: [100, 20, 0]    // Dark red
      }
    };
    
    let currentPreset = colorPresets.aurora;
    
    // Wave generation functions
    function generateWave(x, y, time, waveIndex) {
      const freq1 = 0.003 + waveIndex * 0.001;
      const freq2 = 0.005 + waveIndex * 0.0008;
      const timeOffset = waveIndex * 1.7;
      
      const wave1 = Math.sin(x * freq1 + time * flowSpeed + timeOffset) * 
                   Math.cos(y * freq2 + time * flowSpeed * 0.7 + timeOffset);
      
      const wave2 = Math.sin((x + y) * freq1 * 0.8 + time * flowSpeed * 1.2 + timeOffset) *
                   Math.cos((x - y) * freq2 * 0.6 + time * flowSpeed * 0.9 + timeOffset);
      
      return (wave1 + wave2) * 0.5;
    }
    
    function generateTurbulence(x, y, time) {
      const noise1 = Math.sin(x * 0.01 + time * 0.5) * Math.cos(y * 0.008 + time * 0.3);
      const noise2 = Math.sin((x + y) * 0.006 + time * 0.7) * Math.cos((x - y) * 0.009 + time * 0.4);
      return (noise1 + noise2) * 0.3;
    }
    
    // Color interpolation
    function interpolateColor(color1, color2, factor) {
      return [
        Math.round(color1[0] + (color2[0] - color1[0]) * factor),
        Math.round(color1[1] + (color2[1] - color1[1]) * factor),
        Math.round(color1[2] + (color2[2] - color1[2]) * factor)
      ];
    }
    
    function getPixelColor(x, y, time) {
      let totalWave = 0;
      let maxWave = 0;
      
      // Generate multiple wave layers
      for (let i = 0; i < waveCount; i++) {
        const wave = generateWave(x, y, time, i);
        totalWave += wave * (1 - i * 0.15); // Each wave is slightly weaker
        maxWave += (1 - i * 0.15);
      }
      
      // Normalize wave value
      totalWave = totalWave / maxWave;
      
      // Add turbulence
      const turbulence = generateTurbulence(x, y, time);
      totalWave += turbulence;
      
      // Clamp and transform the wave value
      totalWave = Math.max(-1, Math.min(1, totalWave));
      const waveNormalized = (totalWave + 1) * 0.5; // Convert to 0-1 range
      
      // Create color based on wave intensity
      let color;
      if (waveNormalized < 0.3) {
        // Dark background with subtle hints
        color = interpolateColor(currentPreset.background, currentPreset.primary, waveNormalized * 3.33);
      } else if (waveNormalized < 0.7) {
        // Primary to secondary gradient
        const factor = (waveNormalized - 0.3) / 0.4;
        color = interpolateColor(currentPreset.primary, currentPreset.secondary, factor);
      } else {
        // Bright accent colors
        const factor = (waveNormalized - 0.7) / 0.3;
        color = interpolateColor(currentPreset.secondary, currentPreset.accent, factor);
      }
      
      // Apply intensity
      color = color.map(c => Math.round(c * intensity));
      
      // Add subtle position-based color variation
      const positionHue = Math.sin(x * 0.001 + y * 0.0007 + time * 0.1) * 0.1;
      color = color.map(c => Math.max(0, Math.min(255, c + positionHue * 50)));
      
      return color;
    }
    
    // Main animation loop
    function animate() {
      time += animationSpeed * 0.02;
      
      // Create image data for direct pixel manipulation
      const imageData = ctx.createImageData(canvas.width, canvas.height);
      const data = imageData.data;
      
      // Sample every few pixels for performance
      const step = Math.max(1, Math.floor(Math.min(canvas.width, canvas.height) / 400));
      
      for (let y = 0; y < canvas.height; y += step) {
        for (let x = 0; x < canvas.width; x += step) {
          const color = getPixelColor(x, y, time);
          
          // Fill a small block of pixels for each sample
          for (let dy = 0; dy < step && y + dy < canvas.height; dy++) {
            for (let dx = 0; dx < step && x + dx < canvas.width; dx++) {
              const index = ((y + dy) * canvas.width + (x + dx)) * 4;
              data[index] = color[0];     // Red
              data[index + 1] = color[1]; // Green
              data[index + 2] = color[2]; // Blue
              data[index + 3] = 255;      // Alpha
            }
          }
        }
      }
      
      // Draw the image data
      ctx.putImageData(imageData, 0, 0);
      
      // Add some floating particles for extra magic
      drawParticles();
      
      requestAnimationFrame(animate);
    }
    
    // Floating particle system
    let particles = [];
    
    function initParticles() {
      particles = [];
      for (let i = 0; i < 30; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 0.5) * 2,
          life: Math.random(),
          decay: 0.002 + Math.random() * 0.003,
          size: Math.random() * 3 + 1
        });
      }
    }
    
    function drawParticles() {
      particles.forEach(particle => {
        particle.x += particle.vx * animationSpeed;
        particle.y += particle.vy * animationSpeed;
        particle.life -= particle.decay;
        
        // Wrap around screen
        if (particle.x < 0) particle.x = canvas.width;
        if (particle.x > canvas.width) particle.x = 0;
        if (particle.y < 0) particle.y = canvas.height;
        if (particle.y > canvas.height) particle.y = 0;
        
        // Reset if life expires
        if (particle.life <= 0) {
          particle.life = 1;
          particle.x = Math.random() * canvas.width;
          particle.y = Math.random() * canvas.height;
        }
        
        // Draw particle with glow
        const alpha = particle.life * intensity * 0.7;
        const size = particle.size * particle.life;
        
        const gradient = ctx.createRadialGradient(
          particle.x, particle.y, 0,
          particle.x, particle.y, size * 3
        );
        gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, size * 3, 0, Math.PI * 2);
        ctx.fill();
      });
    }
    
    // Control handlers
    function setupControls() {
      document.getElementById('speed').addEventListener('input', (e) => {
        animationSpeed = parseFloat(e.target.value);
        document.getElementById('speedValue').textContent = animationSpeed.toFixed(1);
      });
      
      document.getElementById('intensity').addEventListener('input', (e) => {
        intensity = parseFloat(e.target.value);
        document.getElementById('intensityValue').textContent = intensity.toFixed(1);
      });
      
      document.getElementById('waves').addEventListener('input', (e) => {
        waveCount = parseInt(e.target.value);
        document.getElementById('wavesValue').textContent = waveCount;
      });
      
      document.getElementById('flow').addEventListener('input', (e) => {
        flowSpeed = parseFloat(e.target.value);
        document.getElementById('flowValue').textContent = flowSpeed.toFixed(1);
      });
    }
    
    // Preset functions
    function setPreset(presetName) {
      currentPreset = colorPresets[presetName];
      
      // Adjust parameters for different presets
      switch(presetName) {
        case 'aurora':
          document.getElementById('speed').value = 1.0;
          document.getElementById('intensity').value = 1.0;
          document.getElementById('waves').value = 4;
          document.getElementById('flow').value = 0.8;
          break;
        case 'plasma':
          document.getElementById('speed').value = 1.5;
          document.getElementById('intensity').value = 1.3;
          document.getElementById('waves').value = 5;
          document.getElementById('flow').value = 1.2;
          break;
        case 'ocean':
          document.getElementById('speed').value = 0.7;
          document.getElementById('intensity').value = 0.9;
          document.getElementById('waves').value = 3;
          document.getElementById('flow').value = 0.6;
          break;
        case 'fire':
          document.getElementById('speed').value = 2.0;
          document.getElementById('intensity').value = 1.4;
          document.getElementById('waves').value = 6;
          document.getElementById('flow').value = 1.5;
          break;
      }
      
      // Update displayed values
      animationSpeed = parseFloat(document.getElementById('speed').value);
      intensity = parseFloat(document.getElementById('intensity').value);
      waveCount = parseInt(document.getElementById('waves').value);
      flowSpeed = parseFloat(document.getElementById('flow').value);
      
      document.getElementById('speedValue').textContent = animationSpeed.toFixed(1);
      document.getElementById('intensityValue').textContent = intensity.toFixed(1);
      document.getElementById('wavesValue').textContent = waveCount;
      document.getElementById('flowValue').textContent = flowSpeed.toFixed(1);
    }
    
    // Fullscreen toggle
    document.addEventListener('keydown', (e) => {
      if (e.key === 'F11') {
        e.preventDefault();
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen();
        } else {
          document.exitFullscreen();
        }
      }
    });
    
    // Hide cursor after inactivity
    let cursorTimeout;
    document.addEventListener('mousemove', () => {
      document.body.style.cursor = 'default';
      clearTimeout(cursorTimeout);
      cursorTimeout = setTimeout(() => {
        document.body.style.cursor = 'none';
      }, 3000);
    });
    
    // Initialize and start
    setupControls();
    initParticles();
    animate();
  </script>
</body>
</html>