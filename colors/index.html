<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Color Theory Explorer - Interactive Palette</title>
  <style>
    :root {
      --bg-color: #f5f5f5;
      --panel-bg: #fff;
      --text-color: #000;
      --border-color: #ddd;
      --canvas-bg: #fff;
    }
    .dark-mode {
      --bg-color: #121212;
      --panel-bg: #1e1e1e;
      --text-color: #e0e0e0;
      --border-color: #333;
      --canvas-bg: #1e1e1e;
    }
    body {
      font-family: sans-serif;
      margin: 20px;
      background: var(--bg-color);
      color: var(--text-color);
      transition: background 0.3s, color 0.3s;
      position: relative;
      user-select: none;
    }
    h1, h2 {
      text-align: center;
    }
    /* Toggle Switch Style */
    .toggle-container {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: 0.4s;
      border-radius: 34px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.4s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: #2196F3;
    }
    input:checked + .slider:before {
      transform: translateX(26px);
    }
    
    /* Main container for landscape layout */
    #mainContainer {
      display: flex;
      flex-direction: row;
      gap: 20px;
      margin-top: 60px; /* leave space for toggle switch */
    }
    /* Left panel: Controls, Theory, and Palette */
    #leftPanel {
      flex: 1;
      max-width: 500px;
      background: var(--panel-bg);
      padding: 20px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
    }
    /* Right panel: Canvas Color Wheel */
    #rightPanel {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: var(--panel-bg);
      padding: 20px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
    }
    canvas {
      border: 1px solid var(--border-color);
      background: var(--canvas-bg);
      transition: background 0.3s, border-color 0.3s;
    }
    #controls, #theory, #paletteDisplay {
      margin-bottom: 20px;
    }
    .palette {
      display: flex;
      margin-top: 10px;
      justify-content: center;
    }
    .colorBlock {
      width: 50px;
      height: 50px;
      margin: 0 5px;
      border: 1px solid var(--border-color);
    }
    /* Style for interactive note */
    .note {
      font-size: 0.9em;
      font-style: italic;
      color: var(--text-color);
      margin-top: 10px;
      text-align: center;
    }
  </style>
</head>
<body>
  <!-- Toggle Switch for Light/Dark Mode -->
  <div class="toggle-container">
    <span>Light</span>
    <label class="toggle-switch">
      <input type="checkbox" id="modeToggle">
      <span class="slider"></span>
    </label>
    <span>Dark</span>
  </div>
  
  <h1>Color Theory Explorer</h1>
  <div id="mainContainer">
    <!-- Left Panel: Controls, Theory, and Generated Palette -->
    <div id="leftPanel">
      <!-- Controls for Palette Generation -->
      <div id="controls">
        <label for="paletteType">Select Palette Type:</label>
        <select id="paletteType">
          <option value="complementary">Complementary</option>
          <option value="analogous">Analogous</option>
          <option value="triadic">Triadic</option>
          <option value="tetradic">Tetradic</option>
        </select>
      </div>
      
      <!-- Color Theory Information -->
      <div id="theory">
        <h2>Color Theory Overview</h2>
        <div id="theoryText">
          <p>
            Color theory is the study of how colors interact, mix, and create visual harmony. It plays a crucial role in art, design, and our everyday visual experiences.
          </p>
          <hr>
          <h3>Complementary Color Scheme</h3>
          <p>
            A complementary color scheme uses two colors that are directly opposite each other on the color wheel. This pairing creates striking contrast and visual impact.
          </p>
          <p class="note">
            Tip: Click and drag a black marker on the color wheel to rotate the palette along its circular arc.
          </p>
        </div>
      </div>
      
      <!-- Display of the Generated Palette -->
      <div id="paletteDisplay">
        <h2>Generated Palette</h2>
        <div id="palette" class="palette"></div>
      </div>
    </div>
    
    <!-- Right Panel: Canvas Color Wheel -->
    <div id="rightPanel">
      <canvas id="colorCanvas" width="500" height="500"></canvas>
    </div>
  </div>
  
  <script>
    const canvas = document.getElementById("colorCanvas");
    const ctx = canvas.getContext("2d");
    const paletteDiv = document.getElementById("palette");
    const paletteSelect = document.getElementById("paletteType");
    const modeToggle = document.getElementById("modeToggle");
    const theoryTextDiv = document.getElementById("theoryText");
    
    const canvasCenter = { x: canvas.width / 2, y: canvas.height / 2 };
    const wheelRadius = canvas.width / 2;
    const markerRadius = wheelRadius * 0.85;
    
    // Global palette data array.
    // Each marker object: { originalHue, currentHue }
    let paletteData = [];
    // Global rotation offset (in degrees) applied to the whole palette.
    let globalOffset = 0;
    
    // Variables for drag interaction.
    let isDragging = false;
    let dragStartAngle = 0;
    let initialOffset = 0;
    
    // Utility: Convert HSL to RGB string.
    function hslToRgb(h, s, l) {
      s /= 100;
      l /= 100;
      let c = (1 - Math.abs(2 * l - 1)) * s;
      let x = c * (1 - Math.abs((h / 60) % 2 - 1));
      let m = l - c / 2;
      let r = 0, g = 0, b = 0;
      if (0 <= h && h < 60) { r = c; g = x; b = 0; }
      else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
      else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
      else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
      else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
      else if (300 <= h && h < 360) { r = c; g = 0; b = x; }
      r = Math.round((r + m) * 255);
      g = Math.round((g + m) * 255);
      b = Math.round((b + m) * 255);
      return "rgb(" + r + "," + g + "," + b + ")";
    }
    
    // Generate a random base hue (0 to 359).
    function getRandomHue() {
      return Math.floor(Math.random() * 360);
    }
    
    // Generate palette data based on the selected type.
    // Each marker stores its original hue and starts with currentHue = originalHue.
    function generatePaletteData() {
      const type = paletteSelect.value;
      const baseHue = getRandomHue();
      let hues = [];
      if (type === "complementary") {
        hues.push(baseHue, (baseHue + 180) % 360);
      } else if (type === "analogous") {
        hues.push((baseHue + 330) % 360, baseHue, (baseHue + 30) % 360);
      } else if (type === "triadic") {
        hues.push(baseHue, (baseHue + 120) % 360, (baseHue + 240) % 360);
      } else if (type === "tetradic") {
        hues.push(baseHue, (baseHue + 90) % 360, (baseHue + 180) % 360, (baseHue + 270) % 360);
      }
      paletteData = hues.map(hue => ({
        originalHue: hue,
        currentHue: hue
      }));
      // Reset global offset.
      globalOffset = 0;
    }
    
    // Draw the full color wheel.
    function drawColorWheel() {
      for (let angle = 0; angle < 360; angle += 1) {
        const startAngle = (angle - 1) * Math.PI / 180;
        const endAngle = angle * Math.PI / 180;
        ctx.beginPath();
        ctx.moveTo(canvasCenter.x, canvasCenter.y);
        ctx.arc(canvasCenter.x, canvasCenter.y, wheelRadius, startAngle, endAngle);
        ctx.closePath();
        ctx.fillStyle = "hsl(" + angle + ", 100%, 50%)";
        ctx.fill();
      }
    }
    
    // Draw palette markers (black dots with a glow) and connecting lines.
    // Uses paletteData's currentHue.
    function drawPaletteOnWheel() {
      const positions = paletteData.map(data => {
        const rad = data.currentHue * Math.PI / 180;
        return {
          x: canvasCenter.x + markerRadius * Math.cos(rad),
          y: canvasCenter.y + markerRadius * Math.sin(rad)
        };
      });
      
      // Draw connecting lines.
      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'black';
      ctx.beginPath();
      positions.forEach((pos, index) => {
        if (index === 0) ctx.moveTo(pos.x, pos.y);
        else ctx.lineTo(pos.x, pos.y);
      });
      if (positions.length > 2) ctx.closePath();
      ctx.stroke();
      ctx.restore();
      
      // Draw markers.
      positions.forEach(pos => {
        ctx.save();
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 6, 0, Math.PI * 2);
        ctx.fillStyle = 'black';
        ctx.shadowColor = 'black';
        ctx.shadowBlur = 10;
        ctx.fill();
        ctx.restore();
      });
    }
    
    // Update the canvas: clear, redraw the wheel, and overlay markers.
    function updateCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawColorWheel();
      drawPaletteOnWheel();
    }
    
    // Update the palette display (color blocks) below the theory.
    function updatePaletteDisplay() {
      paletteDiv.innerHTML = "";
      paletteData.forEach(data => {
        const rgb = hslToRgb(data.currentHue, 70, 50);
        const block = document.createElement("div");
        block.className = "colorBlock";
        block.style.backgroundColor = rgb;
        paletteDiv.appendChild(block);
      });
    }
    
    // Update theory summary based on the palette type.
    function updateTheorySummary(type) {
      let summary = `<p>
          Color theory is the study of how colors interact, mix, and create visual harmony. It plays a crucial role in art, design, and our everyday visual experiences.
        </p>
        <hr>`;
      if (type === "complementary") {
        summary += `<h3>Complementary Color Scheme</h3>
          <p>
            A complementary color scheme uses two colors that are directly opposite each other on the color wheel. This pairing creates striking contrast and visual impact.
          </p>`;
      } else if (type === "analogous") {
        summary += `<h3>Analogous Color Scheme</h3>
          <p>
            An analogous color scheme employs colors that are adjacent on the color wheel. This produces a harmonious and cohesive palette ideal for subtle designs.
          </p>`;
      } else if (type === "triadic") {
        summary += `<h3>Triadic Color Scheme</h3>
          <p>
            A triadic color scheme uses three colors evenly spaced around the color wheel. This results in a vibrant yet balanced combination.
          </p>`;
      } else if (type === "tetradic") {
        summary += `<h3>Tetradic Color Scheme</h3>
          <p>
            A tetradic color scheme consists of two complementary pairs. This configuration yields a rich and multifaceted palette.
          </p>`;
      }
      theoryTextDiv.innerHTML = summary;
    }
    
    // Display a new palette: generate data, update theory, canvas, and display blocks.
    function displayPalette() {
      generatePaletteData();
      updateTheorySummary(paletteSelect.value);
      updateCanvas();
      updatePaletteDisplay();
    }
    
    // Utility: Get mouse position relative to the canvas.
    function getMousePos(evt) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top
      };
    }
    
    // Given an (x, y) point, compute angle (in degrees) from center.
    function getAngleFromCenter(x, y) {
      const dx = x - canvasCenter.x;
      const dy = y - canvasCenter.y;
      let angle = Math.atan2(dy, dx) * (180 / Math.PI);
      if (angle < 0) angle += 360;
      return angle;
    }
    
    // Mouse event handlers for dragging markers.
    canvas.addEventListener("mousedown", function(evt) {
      const pos = getMousePos(evt);
      // Check if mouse is near any marker.
      for (let i = 0; i < paletteData.length; i++) {
        const markerAngle = paletteData[i].currentHue;
        const rad = markerAngle * Math.PI / 180;
        const markerX = canvasCenter.x + markerRadius * Math.cos(rad);
        const markerY = canvasCenter.y + markerRadius * Math.sin(rad);
        const dist = Math.hypot(pos.x - markerX, pos.y - markerY);
        if (dist < 10) { // hit detection threshold
          isDragging = true;
          dragStartAngle = getAngleFromCenter(pos.x, pos.y);
          initialOffset = globalOffset;
          break;
        }
      }
    });
    
    canvas.addEventListener("mousemove", function(evt) {
      if (!isDragging) return;
      const pos = getMousePos(evt);
      const currentAngle = getAngleFromCenter(pos.x, pos.y);
      // Calculate change in angle (delta), taking wrap-around into account.
      let delta = currentAngle - dragStartAngle;
      if (delta > 180) delta -= 360;
      else if (delta < -180) delta += 360;
      
      globalOffset = initialOffset + delta;
      
      // Update every marker's currentHue.
      paletteData.forEach(marker => {
        marker.currentHue = (marker.originalHue + globalOffset + 360) % 360;
      });
      
      updateCanvas();
      updatePaletteDisplay();
    });
    
    canvas.addEventListener("mouseup", function(evt) {
      if (isDragging) {
        // If the full rotation (or near it) has been completed, reset to original.
        if (Math.abs(globalOffset) > 350 && Math.abs(globalOffset) < 370) {
          globalOffset = 0;
          paletteData.forEach(marker => {
            marker.currentHue = marker.originalHue;
          });
        }
      }
      isDragging = false;
      updateCanvas();
      updatePaletteDisplay();
    });
    
    // End dragging if the mouse leaves the canvas.
    canvas.addEventListener("mouseleave", function(evt) {
      if (isDragging) {
        isDragging = false;
        updateCanvas();
        updatePaletteDisplay();
      }
    });
    
    // Toggle light/dark mode.
    modeToggle.addEventListener("change", function() {
      document.body.classList.toggle("dark-mode", modeToggle.checked);
    });
    
    // Regenerate palette when the selection changes.
    paletteSelect.addEventListener("change", displayPalette);
    
    // Initial rendering.
    drawColorWheel();
    displayPalette();
  </script>
</body>
</html>
