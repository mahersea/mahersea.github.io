<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Turbocharger Simulation</title>
  <meta name="description" content="Interactive simulation of a turbocharger showing exhaust gas flow, compressor operation, and boost pressure">
  <style>
    body { 
      margin: 0; 
      background: #111; 
      color: #ffffff;
      font-family: Arial, sans-serif; 
      text-align: center; 
      overflow-x: hidden;
    }
    
    h1 {
      margin-top: 20px;
      margin-bottom: 10px;
    }
    
    .description {
      max-width: 800px;
      margin: 0 auto 20px;
      padding: 0 20px;
      font-size: 14px;
      color: #ccc;
    }
    
    canvas { 
      display: block; 
      margin: 0 auto;
      background: #000; 
    }
    
    .dashboard {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      margin-bottom: 20px;
    }
    
    .gauges {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 10px 0;
      flex-wrap: wrap;
    }
    
    .gauge {
      position: relative;
      width: 120px;
      height: 120px;
      background: #222;
      border-radius: 50%;
      padding: 10px;
      box-shadow: 0 0 10px rgba(0, 100, 200, 0.3);
    }
    
    .gauge-title {
      position: absolute;
      top: 65%;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 12px;
      color: #ddd;
    }
    
    .gauge-value {
      position: absolute;
      top: 80%;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 14px;
      font-weight: bold;
    }
    
    .controls { 
      margin: 10px auto; 
      color: #ffffff;
      display: flex;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
      max-width: 800px;
    }
    
    .control-group {
      display: flex;
      align-items: center;
      gap: 5px;
      background: rgba(0, 0, 0, 0.2);
      padding: 5px 10px;
      border-radius: 4px;
    }
    
    button {
      background: #333;
      color: #fff;
      border: 1px solid #555;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    button:hover {
      background: #444;
    }
    
    button.active {
      background: #224466;
    }
    
    input[type="range"] {
      background: #333;
      accent-color: #4488cc;
    }
    
    .component-label {
      position: absolute;
      font-size: 12px;
      color: #ccc;
      background: rgba(0, 0, 0, 0.6);
      padding: 2px 5px;
      border-radius: 3px;
      pointer-events: none;
    }
    
    @media (max-width: 600px) {
      .controls {
        flex-direction: column;
        align-items: center;
        gap: 8px;
      }
      
      .gauges {
        gap: 10px;
      }
      
      .gauge {
        width: 100px;
        height: 100px;
      }
    }
  </style>
</head>
<body>
  <h1>Turbocharger Simulation</h1>
  <div class="description">
    This simulation demonstrates how a turbocharger increases engine power by using exhaust gas energy to compress intake air.
    Adjust the throttle, RPM, and wastegate to see how they affect the system.
  </div>
  
  <div class="dashboard">
    <div class="gauges">
      <div class="gauge" id="boostGauge">
        <div class="gauge-title">BOOST</div>
        <div class="gauge-value">0.0 bar</div>
      </div>
      <div class="gauge" id="rpmGauge">
        <div class="gauge-title">TURBO RPM</div>
        <div class="gauge-value">0 rpm</div>
      </div>
      <div class="gauge" id="tempGauge">
        <div class="gauge-title">EXH TEMP</div>
        <div class="gauge-value">0 °C</div>
      </div>
    </div>
  </div>
  
  <div class="controls">
    <div class="control-group">
      <button id="startStopBtn">Start Engine</button>
    </div>
    <div class="control-group">
      <label for="throttleRange">Throttle: </label>
      <input type="range" id="throttleRange" min="0" max="100" value="0">
      <span id="throttleValue">0%</span>
    </div>
    <div class="control-group">
      <label for="rpmRange">Engine RPM: </label>
      <input type="range" id="rpmRange" min="800" max="6500" value="800" step="100">
      <span id="rpmValue">800</span>
    </div>
    <div class="control-group">
      <label for="wastegateRange">Wastegate: </label>
      <input type="range" id="wastegateRange" min="0" max="100" value="0">
      <span id="wastegateValue">0%</span>
    </div>
    <div class="control-group">
      <label for="showParticlesCheck">Show Particles: </label>
      <input type="checkbox" id="showParticlesCheck" checked>
    </div>
    <div class="control-group">
      <label for="heatVisualizationCheck">Heat Visualization: </label>
      <input type="checkbox" id="heatVisualizationCheck" checked>
    </div>
  </div>
  
  <canvas id="canvas"></canvas>
  
  <script>
    // Main canvas and context
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas dimensions
    const setCanvasSize = () => {
      const maxWidth = Math.min(window.innerWidth - 40, 1000);
      const maxHeight = Math.min(window.innerHeight - 300, 600);
      canvas.width = maxWidth;
      canvas.height = maxHeight;
    };
    
    setCanvasSize();
    window.addEventListener('resize', setCanvasSize);
    
    // Center of the canvas
    let cx = canvas.width / 2;
    let cy = canvas.height / 2;
    
    // Animation variables
    let animationId;
    let isEngineRunning = false;
    let lastTimestamp = 0;
    
    // Engine parameters
    let throttle = 0;
    let engineRPM = 800;
    let wastegateOpening = 0;
    let turbineRPM = 0;
    let boostPressure = 0;
    let exhaustTemperature = 20; // ambient temperature in °C
    
    // Particles
    let exhaustParticles = [];
    let intakeParticles = [];
    let showParticles = true;
    let showHeatVisualization = true;
    
    // Turbocharger dimensions
    const turbineRadius = 50;
    const compressorRadius = 50;
    const shaftLength = 120;
    const turbineCenter = { x: cx - shaftLength / 2, y: cy };
    const compressorCenter = { x: cx + shaftLength / 2, y: cy };
    
    // Inlet and outlet dimensions
    const pipeWidth = 25;
    const pipeLength = 70;
    
    // Controls
    const startStopBtn = document.getElementById('startStopBtn');
    const throttleRange = document.getElementById('throttleRange');
    const throttleValue = document.getElementById('throttleValue');
    const rpmRange = document.getElementById('rpmRange');
    const rpmValue = document.getElementById('rpmValue');
    const wastegateRange = document.getElementById('wastegateRange');
    const wastegateValue = document.getElementById('wastegateValue');
    const showParticlesCheck = document.getElementById('showParticlesCheck');
    const heatVisualizationCheck = document.getElementById('heatVisualizationCheck');
    
    // Gauges
    const boostGauge = document.getElementById('boostGauge');
    const rpmGauge = document.getElementById('rpmGauge');
    const tempGauge = document.getElementById('tempGauge');
    
    // Event listeners
    startStopBtn.addEventListener('click', () => {
      isEngineRunning = !isEngineRunning;
      startStopBtn.textContent = isEngineRunning ? 'Stop Engine' : 'Start Engine';
      startStopBtn.classList.toggle('active', isEngineRunning);
      
      if (isEngineRunning) {
        // Initialize and start animation
        lastTimestamp = 0;
        animationId = requestAnimationFrame(animate);
      } else {
        // Stop animation
        cancelAnimationFrame(animationId);
        resetSimulation();
      }
    });
    
    throttleRange.addEventListener('input', () => {
      throttle = parseInt(throttleRange.value);
      throttleValue.textContent = `${throttle}%`;
    });
    
    rpmRange.addEventListener('input', () => {
      engineRPM = parseInt(rpmRange.value);
      rpmValue.textContent = engineRPM;
    });
    
    wastegateRange.addEventListener('input', () => {
      wastegateOpening = parseInt(wastegateRange.value);
      wastegateValue.textContent = `${wastegateOpening}%`;
    });
    
    showParticlesCheck.addEventListener('change', () => {
      showParticles = showParticlesCheck.checked;
    });
    
    heatVisualizationCheck.addEventListener('change', () => {
      showHeatVisualization = heatVisualizationCheck.checked;
    });
    
    // Initialize particles
    function initParticles() {
      exhaustParticles = [];
      intakeParticles = [];
    }
    
    // Reset simulation
    function resetSimulation() {
      turbineRPM = 0;
      boostPressure = 0;
      exhaustTemperature = 20;
      initParticles();
      updateGauges();
    }
    
    // Update gauges
    function updateGauges() {
      // Update boost gauge
      const boostValue = document.querySelector('#boostGauge .gauge-value');
      boostValue.textContent = `${boostPressure.toFixed(1)} bar`;
      
      // Update RPM gauge
      const rpmValue = document.querySelector('#rpmGauge .gauge-value');
      rpmValue.textContent = `${Math.round(turbineRPM)} rpm`;
      
      // Update temperature gauge
      const tempValue = document.querySelector('#tempGauge .gauge-value');
      tempValue.textContent = `${Math.round(exhaustTemperature)} °C`;
      
      // Draw gauge graphics
      drawGauge(boostGauge, boostPressure, 0, 2, '#4488cc');
      drawGauge(rpmGauge, turbineRPM, 0, 200000, '#cc8844');
      drawGauge(tempGauge, exhaustTemperature, 0, 1000, '#cc4444');
    }
    
    // Draw gauge
    function drawGauge(element, value, min, max, color) {
      const gaugeCtx = element.__gaugeCtx;
      const width = element.clientWidth;
      const height = element.clientHeight;
      
      // Create canvas if it doesn't exist
      if (!gaugeCtx) {
        const gaugeCanvas = document.createElement('canvas');
        gaugeCanvas.width = width;
        gaugeCanvas.height = height;
        element.insertBefore(gaugeCanvas, element.firstChild);
        element.__gaugeCtx = gaugeCanvas.getContext('2d');
      }
      
      const ctx = element.__gaugeCtx;
      const centerX = width / 2;
      const centerY = height / 2;
      const radius = Math.min(centerX, centerY) - 5;
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Draw gauge background
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, Math.PI * 0.75, Math.PI * 2.25, false);
      ctx.lineWidth = 10;
      ctx.strokeStyle = '#333';
      ctx.stroke();
      
      // Calculate angle based on value
      const percentage = Math.min(Math.max((value - min) / (max - min), 0), 1);
      const angle = (percentage * 1.5 + 0.75) * Math.PI;
      
      // Draw gauge value
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, Math.PI * 0.75, angle, false);
      ctx.lineWidth = 10;
      ctx.strokeStyle = color;
      ctx.stroke();
      
      // Draw center cap
      ctx.beginPath();
      ctx.arc(centerX, centerY, 15, 0, Math.PI * 2);
      ctx.fillStyle = '#222';
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#444';
      ctx.stroke();
      
      // Draw tick marks
      for (let i = 0; i <= 6; i++) {
        const tickAngle = (i / 6 * 1.5 + 0.75) * Math.PI;
        const innerRadius = radius - 10;
        const outerRadius = radius + 5;
        
        ctx.beginPath();
        ctx.moveTo(
          centerX + innerRadius * Math.cos(tickAngle),
          centerY + innerRadius * Math.sin(tickAngle)
        );
        ctx.lineTo(
          centerX + outerRadius * Math.cos(tickAngle),
          centerY + outerRadius * Math.sin(tickAngle)
        );
        ctx.lineWidth = i % 3 === 0 ? 3 : 1;
        ctx.strokeStyle = '#aaa';
        ctx.stroke();
      }
    }
    
    // Draw turbocharger components
    function drawTurbocharger() {
      // Common angles for turbine and compressor blades
      const numBlades = 6;
      const baseAngle = performance.now() / 1000 * (turbineRPM / 10000);
      
      // Draw connecting shaft
      ctx.lineWidth = 12;
      ctx.strokeStyle = '#555';
      ctx.beginPath();
      ctx.moveTo(turbineCenter.x + 15, turbineCenter.y);
      ctx.lineTo(compressorCenter.x - 15, compressorCenter.y);
      ctx.stroke();
      
      // Draw shaft ends
      ctx.fillStyle = '#777';
      ctx.beginPath();
      ctx.arc(turbineCenter.x + 15, turbineCenter.y, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(compressorCenter.x - 15, compressorCenter.y, 8, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw turbine housing
      const turbineHousingGradient = ctx.createRadialGradient(
        turbineCenter.x, turbineCenter.y, 0,
        turbineCenter.x, turbineCenter.y, turbineRadius + 15
      );
      turbineHousingGradient.addColorStop(0, showHeatVisualization ? `rgba(120, 50, 0, 0.8)` : 'rgba(80, 80, 80, 0.8)');
      turbineHousingGradient.addColorStop(1, showHeatVisualization ? `rgba(200, 70, 30, 0.9)` : 'rgba(60, 60, 60, 0.9)');
      
      ctx.fillStyle = turbineHousingGradient;
      ctx.beginPath();
      ctx.arc(turbineCenter.x, turbineCenter.y, turbineRadius + 15, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw compressor housing
      const compressorHousingGradient = ctx.createRadialGradient(
        compressorCenter.x, compressorCenter.y, 0,
        compressorCenter.x, compressorCenter.y, compressorRadius + 15
      );
      compressorHousingGradient.addColorStop(0, 'rgba(40, 80, 120, 0.8)');
      compressorHousingGradient.addColorStop(1, 'rgba(30, 60, 100, 0.9)');
      
      ctx.fillStyle = compressorHousingGradient;
      ctx.beginPath();
      ctx.arc(compressorCenter.x, compressorCenter.y, compressorRadius + 15, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw turbine wheel
      const turbineGradient = ctx.createRadialGradient(
        turbineCenter.x, turbineCenter.y, 0,
        turbineCenter.x, turbineCenter.y, turbineRadius
      );
      turbineGradient.addColorStop(0, showHeatVisualization ? '#ffaa77' : '#aaa');
      turbineGradient.addColorStop(1, showHeatVisualization ? '#cc7755' : '#888');
      
      ctx.fillStyle = turbineGradient;
      ctx.beginPath();
      ctx.arc(turbineCenter.x, turbineCenter.y, turbineRadius, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw turbine blades
      ctx.fillStyle = showHeatVisualization ? '#ffcc99' : '#999';
      for (let i = 0; i < numBlades; i++) {
        const angle = baseAngle + (i / numBlades) * Math.PI * 2;
        
        ctx.save();
        ctx.translate(turbineCenter.x, turbineCenter.y);
        ctx.rotate(angle);
        
        // Draw curved blade
        ctx.beginPath();
        ctx.moveTo(0, -5);
        ctx.quadraticCurveTo(turbineRadius * 0.7, -15, turbineRadius, -10);
        ctx.lineTo(turbineRadius, 10);
        ctx.quadraticCurveTo(turbineRadius * 0.7, 15, 0, 5);
        ctx.fill();
        
        ctx.restore();
      }
      
      // Draw turbine center
      ctx.fillStyle = showHeatVisualization ? '#ff9955' : '#666';
      ctx.beginPath();
      ctx.arc(turbineCenter.x, turbineCenter.y, 15, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw compressor wheel
      const compressorGradient = ctx.createRadialGradient(
        compressorCenter.x, compressorCenter.y, 0,
        compressorCenter.x, compressorCenter.y, compressorRadius
      );
      compressorGradient.addColorStop(0, '#99ccff');
      compressorGradient.addColorStop(1, '#6699cc');
      
      ctx.fillStyle = compressorGradient;
      ctx.beginPath();
      ctx.arc(compressorCenter.x, compressorCenter.y, compressorRadius, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw compressor blades
      ctx.fillStyle = '#7799cc';
      for (let i = 0; i < numBlades; i++) {
        const angle = baseAngle + (i / numBlades) * Math.PI * 2;
        
        ctx.save();
        ctx.translate(compressorCenter.x, compressorCenter.y);
        ctx.rotate(angle);
        
        // Draw curved blade (opposite direction from turbine)
        ctx.beginPath();
        ctx.moveTo(0, -5);
        ctx.quadraticCurveTo(compressorRadius * 0.7, 15, compressorRadius, 10);
        ctx.lineTo(compressorRadius, -10);
        ctx.quadraticCurveTo(compressorRadius * 0.7, -15, 0, 5);
        ctx.fill();
        
        ctx.restore();
      }
      
      // Draw compressor center
      ctx.fillStyle = '#5588cc';
      ctx.beginPath();
      ctx.arc(compressorCenter.x, compressorCenter.y, 15, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw exhaust inlet pipe
      ctx.fillStyle = showHeatVisualization ? `rgba(${120 + exhaustTemperature * 0.3}, 50, 30, 0.9)` : 'rgba(70, 70, 70, 0.9)';
      ctx.beginPath();
      ctx.rect(turbineCenter.x - turbineRadius - 15 - pipeLength, turbineCenter.y - pipeWidth, pipeLength, pipeWidth * 2);
      ctx.fill();
      
      // Draw exhaust outlet pipe
      ctx.fillStyle = showHeatVisualization ? `rgba(${100 + exhaustTemperature * 0.2}, 50, 30, 0.8)` : 'rgba(70, 70, 70, 0.8)';
      ctx.beginPath();
      ctx.rect(turbineCenter.x - pipeWidth, turbineCenter.y + turbineRadius + 15, pipeWidth * 2, pipeLength);
      ctx.fill();
      
      // Draw wastegate
      const wastegateX = turbineCenter.x - turbineRadius - 15 - pipeLength/2;
      const wastegateY = turbineCenter.y - pipeWidth - 10;
      const wastegateWidth = 30;
      const wastegateHeight = 10;
      const wastegateOpened = wastegateHeight * (wastegateOpening / 100);
      
      ctx.fillStyle = '#555';
      ctx.beginPath();
      ctx.rect(wastegateX - wastegateWidth/2, wastegateY - wastegateHeight, wastegateWidth, wastegateHeight);
      ctx.fill();
      
      // Draw wastegate opening
      if (wastegateOpening > 0) {
        ctx.fillStyle = showHeatVisualization ? `rgba(${120 + exhaustTemperature * 0.3}, 50, 30, 0.9)` : 'rgba(100, 100, 100, 0.9)';
        ctx.beginPath();
        ctx.rect(wastegateX - wastegateWidth/2, wastegateY - wastegateOpened, wastegateWidth, wastegateOpened);
        ctx.fill();
      }
      
      // Draw wastegate bypass pipe if opened
      if (wastegateOpening > 0) {
        ctx.fillStyle = showHeatVisualization ? `rgba(${100 + exhaustTemperature * 0.2}, 50, 30, 0.8)` : 'rgba(80, 80, 80, 0.8)';
        ctx.beginPath();
        ctx.rect(wastegateX - pipeWidth, wastegateY - wastegateHeight - pipeLength, pipeWidth * 2, pipeLength);
        ctx.fill();
      }
      
      // Draw intake inlet pipe
      ctx.fillStyle = 'rgba(50, 50, 80, 0.9)';
      ctx.beginPath();
      ctx.rect(compressorCenter.x - pipeWidth, compressorCenter.y - turbineRadius - 15 - pipeLength, pipeWidth * 2, pipeLength);
      ctx.fill();
      
      // Draw intake outlet pipe (boost pipe)
      const boostColor = `rgba(${50 + boostPressure * 25}, ${80 + boostPressure * 10}, ${120 + boostPressure * 10}, 0.9)`;
      ctx.fillStyle = boostColor;
      ctx.beginPath();
      ctx.rect(compressorCenter.x + compressorRadius + 15, compressorCenter.y - pipeWidth, pipeLength, pipeWidth * 2);
      ctx.fill();
      
      // Draw intercooler
      if (boostPressure > 0.1) {
        const intercoolerX = compressorCenter.x + compressorRadius + 15 + pipeLength;
        const intercoolerY = compressorCenter.y - pipeWidth * 1.5;
        const intercoolerWidth = 40;
        const intercoolerHeight = pipeWidth * 3;
        
        // Draw intercooler body
        const coolerTemp = Math.min(1, boostPressure / 2);
        const coolR = Math.round(50 + 30 * coolerTemp);
        const coolG = Math.round(80 + 40 * coolerTemp);
        const coolB = Math.round(120 + 40 * coolerTemp);
        
        ctx.fillStyle = `rgb(${coolR}, ${coolG}, ${coolB})`;
        ctx.beginPath();
        ctx.rect(intercoolerX, intercoolerY, intercoolerWidth, intercoolerHeight);
        ctx.fill();
        
        // Draw cooling fins
        ctx.fillStyle = '#ccc';
        const numFins = 8;
        const finWidth = 2;
        const finSpacing = (intercoolerWidth - (numFins * finWidth)) / (numFins - 1);
        
        for (let i = 0; i < numFins; i++) {
          const finX = intercoolerX + i * (finWidth + finSpacing);
          ctx.beginPath();
          ctx.rect(finX, intercoolerY - 5, finWidth, intercoolerHeight + 10);
          ctx.fill();
        }
        
        // Draw outlet pipe
        ctx.fillStyle = `rgba(${50 + boostPressure * 15}, ${80 + boostPressure * 20}, ${120 + boostPressure * 20}, 0.9)`;
        ctx.beginPath();
        ctx.rect(intercoolerX + intercoolerWidth, intercoolerY, pipeLength / 2, intercoolerHeight);
        ctx.fill();
      }
      
      // Draw engine block (simplified)
      const engineX = compressorCenter.x + compressorRadius + 15 + pipeLength * 2;
      const engineY = compressorCenter.y - 40;
      const engineWidth = 80;
      const engineHeight = 80;
      
      // Draw engine body
      ctx.fillStyle = '#444';
      ctx.beginPath();
      ctx.rect(engineX, engineY, engineWidth, engineHeight);
      ctx.fill();
      
      // Draw engine details
      ctx.fillStyle = '#333';
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.rect(engineX + 10, engineY + 10 + i * 25, engineWidth - 20, 15);
        ctx.fill();
      }
      
      // Draw exhaust pipe from engine
      ctx.fillStyle = showHeatVisualization ? `rgba(${100 + exhaustTemperature * 0.4}, 40, 20, 0.9)` : 'rgba(60, 60, 60, 0.9)';
      ctx.beginPath();
      ctx.rect(engineX - pipeLength, engineY + engineHeight - pipeWidth, pipeLength, pipeWidth * 2);
      ctx.fill();
      
      // Draw connecting pipe from engine exhaust to turbo inlet
      ctx.fillStyle = showHeatVisualization ? `rgba(${100 + exhaustTemperature * 0.3}, 40, 20, 0.9)` : 'rgba(60, 60, 60, 0.9)';
      ctx.beginPath();
      ctx.rect(turbineCenter.x - turbineRadius - 15 - pipeLength, engineY + engineHeight - pipeWidth, pipeWidth * 2, turbineCenter.y - (engineY + engineHeight - pipeWidth));
      ctx.fill();
      
      // Add component labels
      drawComponentLabel("Turbine", turbineCenter.x, turbineCenter.y - turbineRadius - 25);
      drawComponentLabel("Compressor", compressorCenter.x, compressorCenter.y - compressorRadius - 25);
      drawComponentLabel("Wastegate", wastegateX, wastegateY - wastegateHeight - 15);
      drawComponentLabel("Engine", engineX + engineWidth / 2, engineY - 10);
      
      if (boostPressure > 0.1) {
        const intercoolerX = compressorCenter.x + compressorRadius + 15 + pipeLength + 20;
        const intercoolerY = compressorCenter.y - pipeWidth * 1.5 - 15;
        drawComponentLabel("Intercooler", intercoolerX, intercoolerY);
      }
    }
    
    // Draw component label
    function drawComponentLabel(text, x, y) {
      ctx.font = '12px Arial';
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.fillText(text, x, y);
    }
    
    // Generate particles
    function generateParticles(deltaTime) {
      if (!showParticles || !isEngineRunning) return;
      
      const throttleFactor = throttle / 100;
      const rpmFactor = (engineRPM - 800) / 5700;
      
      // Generate exhaust particles
      const exhaustRate = Math.round(deltaTime * 0.05 * throttleFactor * (1 + rpmFactor));
      const exhaustX = turbineCenter.x - turbineRadius - 15 - pipeLength;
      const exhaustY = turbineCenter.y;
      
      for (let i = 0; i < exhaustRate; i++) {
        const randomY = exhaustY + (Math.random() - 0.5) * pipeWidth;
        
        exhaustParticles.push({
          x: exhaustX,
          y: randomY,
          vx: 2 + Math.random() * 2 * throttleFactor * (1 + rpmFactor),
          vy: (Math.random() - 0.5) * 0.5,
          size: 2 + Math.random() * 3,
          temp: 100 + (engineRPM - 800) / 5700 * 900 * throttleFactor,
          life: 100,
          inTurbine: false,
          throughTurbine: false
        });
      }
      
      // Generate intake particles
      const intakeRate = Math.round(deltaTime * 0.03 * (1 + boostPressure));
      const intakeX = compressorCenter.x;
      const intakeY = compressorCenter.y - turbineRadius - 15 - pipeLength;
      
      for (let i = 0; i < intakeRate; i++) {
        const randomX = intakeX + (Math.random() - 0.5) * pipeWidth;
        
        intakeParticles.push({
          x: randomX,
          y: intakeY,
          vx: (Math.random() - 0.5) * 0.5,
          vy: 1 + Math.random() * (1 + boostPressure * 0.5),
          size: 2 + Math.random() * 2,
          pressure: 1,
          life: 100,
          inCompressor: false,
          throughCompressor: false
        });
      }
    }
    
    // Update particles
    function updateParticles(deltaTime) {
      if (!showParticles) return;
      
      const dt = deltaTime / 16;
      
      // Update exhaust particles
      for (let i = exhaustParticles.length - 1; i >= 0; i--) {
        const p = exhaustParticles[i];
        
        // Update position
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        
        // Handle wastegate diversion
        const wastegateX = turbineCenter.x - turbineRadius - 15 - pipeLength/2;
        const wastegateY = turbineCenter.y - pipeWidth - 10;
        
        if (wastegateOpening > 0 && 
            p.x >= wastegateX - 15 && p.x <= wastegateX + 15 && 
            p.y <= turbineCenter.y - pipeWidth/2) {
          
          // Chance to divert through wastegate based on opening percentage
          if (Math.random() * 100 < wastegateOpening) {
            // Redirect particle through wastegate
            p.vy = -2 - Math.random() * 2;
            p.vx = (Math.random() - 0.5) * 0.5;
            p.throughTurbine = true; // Mark as bypassed turbine
          }
        }
        
        // Check if particle enters turbine
        const distToTurbine = Math.sqrt(
          Math.pow(p.x - turbineCenter.x, 2) + 
          Math.pow(p.y - turbineCenter.y, 2)
        );
        
        if (!p.inTurbine && !p.throughTurbine && distToTurbine < turbineRadius) {
          p.inTurbine = true;
          
          // Adjust velocity based on turbine rotation
          const angle = Math.atan2(p.y - turbineCenter.y, p.x - turbineCenter.x);
          const tangentialSpeed = turbineRPM / 20000;
          
          p.vx = Math.cos(angle + Math.PI/2) * tangentialSpeed;
          p.vy = Math.sin(angle + Math.PI/2) * tangentialSpeed;
          
          // Add some randomness
          p.vx += (Math.random() - 0.5) * 0.5;
          p.vy += (Math.random() - 0.5) * 0.5;
        }
        
        // Check if particle exits turbine
        if (p.inTurbine && distToTurbine > turbineRadius) {
          p.inTurbine = false;
          p.throughTurbine = true;
          
          // Direct towards exhaust outlet
          const angle = Math.atan2(
            turbineCenter.y + turbineRadius + pipeLength/2 - p.y,
            turbineCenter.x - p.x
          );
          
          p.vx = Math.cos(angle) * (2 + Math.random());
          p.vy = Math.sin(angle) * (2 + Math.random());
        }
        
        // Reduce life and temperature
        p.life -= dt;
        p.temp -= dt * 0.5;
        
        // Remove dead particles
        if (p.life <= 0 || 
            p.x > canvas.width || p.x < 0 || 
            p.y > canvas.height || p.y < 0) {
          exhaustParticles.splice(i, 1);
        }
      }
      
      // Update intake particles
      for (let i = intakeParticles.length - 1; i >= 0; i--) {
        const p = intakeParticles[i];
        
        // Update position
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        
        // Check if particle enters compressor
        const distToCompressor = Math.sqrt(
          Math.pow(p.x - compressorCenter.x, 2) + 
          Math.pow(p.y - compressorCenter.y, 2)
        );
        
        if (!p.inCompressor && !p.throughCompressor && distToCompressor < compressorRadius) {
          p.inCompressor = true;
          
          // Adjust velocity based on compressor rotation
          const angle = Math.atan2(p.y - compressorCenter.y, p.x - compressorCenter.x);
          const tangentialSpeed = turbineRPM / 20000;
          
          p.vx = Math.cos(angle - Math.PI/2) * tangentialSpeed;
          p.vy = Math.sin(angle - Math.PI/2) * tangentialSpeed;
          
          // Add some randomness
          p.vx += (Math.random() - 0.5) * 0.5;
          p.vy += (Math.random() - 0.5) * 0.5;
          
          // Increase pressure
          p.pressure = 1 + boostPressure;
        }
        
        // Check if particle exits compressor
        if (p.inCompressor && distToCompressor > compressorRadius) {
          p.inCompressor = false;
          p.throughCompressor = true;
          
          // Direct towards boost outlet
          const angle = Math.atan2(
            compressorCenter.y - p.y,
            compressorCenter.x + compressorRadius + pipeLength/2 - p.x
          );
          
          const speedBoost = 1 + boostPressure * 0.5;
          p.vx = Math.cos(angle) * (2 + Math.random()) * speedBoost;
          p.vy = Math.sin(angle) * (2 + Math.random()) * speedBoost;
        }
        
        // Reduce life
        p.life -= dt;
        
        // Remove dead particles
        if (p.life <= 0 || 
            p.x > canvas.width || p.x < 0 || 
            p.y > canvas.height || p.y < 0) {
          intakeParticles.splice(i, 1);
        }
      }
    }
    
    // Draw particles
    function drawParticles() {
      if (!showParticles) return;
      
      // Draw exhaust particles
      exhaustParticles.forEach(p => {
        const alpha = Math.min(1, p.life / 50);
        
        if (showHeatVisualization) {
          // Color based on temperature
          const r = Math.min(255, 150 + p.temp * 0.2);
          const g = Math.min(150, 50 + p.temp * 0.1);
          const b = Math.min(100, p.temp * 0.05);
          ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
        } else {
          ctx.fillStyle = `rgba(150, 150, 150, ${alpha})`;
        }
        
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });
      
      // Draw intake particles
      intakeParticles.forEach(p => {
        const alpha = Math.min(1, p.life / 50);
        
        // Color based on pressure
        const b = Math.min(255, 150 + p.pressure * 50);
        const g = Math.min(200, 100 + p.pressure * 30);
        const r = Math.min(150, 50 + p.pressure * 20);
        
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });
    }
    
    // Update simulation physics
    function updatePhysics(deltaTime) {
      const dt = deltaTime / 16;
      
      if (!isEngineRunning) {
        // Engine not running, gradually slow down turbo
        turbineRPM *= 0.98;
        boostPressure *= 0.95;
        exhaustTemperature = Math.max(20, exhaustTemperature * 0.99);
        return;
      }
      
      // Calculate exhaust energy based on throttle and RPM
      const throttleFactor = throttle / 100;
      const rpmFactor = (engineRPM - 800) / 5700; // Normalized 0-1 for RPM range
      
      // Calculate exhaust flow diverted through wastegate
      const wastegateFactor = 1 - (wastegateOpening / 100);
      
      // Update exhaust temperature
      const targetExhaustTemp = 20 + 800 * throttleFactor * (0.2 + 0.8 * rpmFactor);
      exhaustTemperature = exhaustTemperature * 0.99 + targetExhaustTemp * 0.01;
      
      // Update turbine RPM based on exhaust energy
      const exhaustEnergy = throttleFactor * (0.1 + 0.9 * rpmFactor) * wastegateFactor;
      const targetTurbineRPM = 200000 * exhaustEnergy;
      
      // Apply turbo lag (gradual acceleration/deceleration)
      const turboLag = 0.05;
      turbineRPM = turbineRPM * (1 - turboLag) + targetTurbineRPM * turboLag;
      
      // Calculate boost pressure based on turbine RPM
      const maxBoostPressure = 2.0; // maximum boost in bar
      const targetBoost = Math.max(0, (turbineRPM / 200000) * maxBoostPressure);
      
      // Apply boost lag
      const boostLag = 0.02;
      boostPressure = boostPressure * (1 - boostLag) + targetBoost * boostLag;
    }
    
    // Animation loop
    function animate(timestamp) {
      // Calculate delta time for smooth animation
      const deltaTime = lastTimestamp ? timestamp - lastTimestamp : 16;
      lastTimestamp = timestamp;
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Center point may change if canvas is resized
      cx = canvas.width / 2;
      cy = canvas.height / 2;
      
      // Update turbine/compressor centers
      turbineCenter.x = cx - shaftLength / 2;
      turbineCenter.y = cy;
      compressorCenter.x = cx + shaftLength / 2;
      compressorCenter.y = cy;
      
      // Update physics
      updatePhysics(deltaTime);
      
      // Generate and update particles
      generateParticles(deltaTime);
      updateParticles(deltaTime);
      
      // Draw components and particles
      drawTurbocharger();
      drawParticles();
      
      // Update gauges
      updateGauges();
      
      // Continue animation
      if (isEngineRunning) {
        animationId = requestAnimationFrame(animate);
      }
    }
    
    // Initialize gauges
    updateGauges();
    
    // Draw static components for initial view
    drawTurbocharger();
  </script>
</body>
</html>