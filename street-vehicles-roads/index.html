<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Street Vehicles - Closed Road Network</title>
  <meta name="description" content="Interactive closed-road traffic simulation with vehicle pathfinding, trail tracking, and raga-based sound effects">
  <style>
    body { 
      margin: 0; 
      background: #1a1a1a; 
      color: #ffffff;
      font-family: Arial, sans-serif; 
      overflow: hidden;
    }
    .container {
      display: grid;
      grid-template-columns: 1fr 300px;
      height: 100vh;
    }
    .simulation-view {
      position: relative;
      background: #2a4a2a; /* Grass/ground color */
    }
    .controls-panel {
      background: #1a1a1a;
      padding: 20px;
      overflow-y: auto;
      border-left: 2px solid #333;
    }
    canvas {
      display: block;
      outline: none;
      position: relative;
      background: #2a4a2a;
    }
    .cursor-indicator {
      position: absolute;
      border: 3px solid #ff6b35;
      background: rgba(255, 107, 53, 0.3);
      pointer-events: none;
      z-index: 10;
      transition: all 0.1s ease;
      box-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
    }
    .control-group {
      margin-bottom: 20px;
      padding: 15px;
      background: #2a2a2a;
      border-radius: 8px;
      border: 1px solid #444;
    }
    .control-group h3 {
      margin: 0 0 10px 0;
      color: #ff6b35;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .slider-group {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin: 8px 0;
    }
    .slider-group label {
      font-size: 12px;
      min-width: 80px;
      color: #ccc;
    }
    input[type="range"] {
      flex: 1;
      margin: 0 10px;
      accent-color: #ff6b35;
    }
    select {
      background: #333;
      color: #fff;
      border: 1px solid #555;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      margin: 0 5px;
    }
    .value-display {
      font-family: monospace;
      font-size: 12px;
      color: #ff6b35;
      min-width: 50px;
      text-align: right;
      font-weight: bold;
    }
    button {
      background: #333;
      color: #fff;
      border: 1px solid #555;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      margin: 2px;
      font-size: 12px;
      transition: all 0.2s;
    }
    button:hover {
      background: #444;
      border-color: #666;
    }
    button.active {
      background: #ff6b35;
      border-color: #ff6b35;
      box-shadow: 0 0 10px rgba(255, 107, 53, 0.3);
    }
    .stats {
      background: #0a0a0a;
      padding: 10px;
      border-radius: 8px;
      margin: 10px 0;
      font-family: monospace;
      font-size: 12px;
      border: 1px solid #333;
    }
    .metric {
      display: flex;
      justify-content: space-between;
      margin: 5px 0;
      padding: 2px 0;
    }
    .metric-value {
      color: #ff6b35;
      font-weight: bold;
    }
    .mode-buttons {
      display: flex;
      gap: 5px;
      flex-wrap: wrap;
      margin: 10px 0;
    }
    .info-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 8px;
      max-width: 300px;
      font-size: 12px;
      border: 1px solid #333;
    }
    .trail-strength {
      width: 100%;
      height: 6px;
      background: linear-gradient(to right, #000000, #440000, #880000, #ff4400, #ff8844);
      border-radius: 3px;
      margin: 5px 0;
    }
    kbd {
      background: #333;
      border: 1px solid #555;
      border-radius: 3px;
      padding: 2px 6px;
      font-size: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="simulation-view">
      <canvas id="canvas" tabindex="0"></canvas>
      <div class="cursor-indicator" id="cursorIndicator"></div>
      <div class="info-panel">
        <h3>üõ£Ô∏è Closed Road Network Simulation</h3>
        <p><strong>Keyboard Controls:</strong></p>
        <p><kbd>D</kbd>: Add destination | <kbd>T</kbd>: Add traffic light</p>
        <p><kbd>R</kbd>: Add road segment | <kbd>V</kbd>: Add vehicles</p>
        <p><kbd>S</kbd>: Toggle sound | <kbd>C</kbd>: Clear trails</p>
        <p><kbd>ESC</kbd>: Reset simulation | <kbd>P</kbd>: Pause/Resume</p>
        <p><kbd>‚Üë‚Üì‚Üê‚Üí</kbd>: Move cursor | <strong>Road-based placement!</strong></p>
        <br>
        <div style="font-size: 11px; color: #aaa;">
          Traffic Density:
          <div class="trail-strength"></div>
          Light ‚Üí Heavy
        </div>
        <br>
        <div style="font-size: 11px; color: #ff6b35; margin-top: 5px;">
          Cursor: <span id="cursorPos">0, 0</span>
        </div>
      </div>
    </div>
    
    <div class="controls-panel">
      <h2>üõ£Ô∏è Road Network Control</h2>
      
      
      <div class="stats">
        <div class="metric">
          <span>Vehicles:</span>
          <span class="metric-value" id="vehicleCount">0</span>
        </div>
        <div class="metric">
          <span>Destinations:</span>
          <span class="metric-value" id="destinationCount">0</span>
        </div>
        <div class="metric">
          <span>Traffic Lights:</span>
          <span class="metric-value" id="trafficLightCount">0</span>
        </div>
        <div class="metric">
          <span>Road Segments:</span>
          <span class="metric-value" id="roadCount">0</span>
        </div>
        <div class="metric">
          <span>Traffic Density:</span>
          <span class="metric-value" id="trafficDensity">0%</span>
        </div>
        <div class="metric">
          <span>Avg Speed:</span>
          <span class="metric-value" id="avgSpeed">0 mph</span>
        </div>
      </div>
      
      <div class="control-group">
        <h3>Raga & Sound</h3>
        <div class="slider-group">
          <label>Sound Volume:</label>
          <input type="range" id="soundVolume" min="0" max="100" value="50">
          <span class="value-display" id="soundVolumeValue">50%</span>
        </div>
        <button id="soundToggle" class="active">üîä Sound On</button>
        <div class="slider-group">
          <label>Raga:</label>
          <select id="ragaSelect">
            <option value="none" selected>None (Default)</option>
            <option value="Bilawal">Bilawal (C Major)</option>
            <option value="Yaman">Yaman (Lydian)</option>
            <option value="Kalyan">Kalyan (Bright Major)</option>
            <option value="Bhairavi">Bhairavi (Natural Minor)</option>
          </select>
        </div>
        <div style="font-size: 10px; color: #aaa; margin: 5px 0;">
          üéµ Car=1st ‚Ä¢ Truck=2nd ‚Ä¢ Bus=3rd ‚Ä¢ Bike=4th ‚Ä¢ Emergency=5th ‚Ä¢ Skateboard=6th ‚Ä¢ Pedestrian=7th
        </div>
      </div>
      
      <div class="control-group">
        <h3>Road Network</h3>
        <div class="slider-group">
          <label>Road Width:</label>
          <input type="range" id="roadWidth" min="20" max="60" value="30">
          <span class="value-display" id="roadWidthValue">30</span>
        </div>
        <div class="mode-buttons">
          <button id="mode-build" class="active">Build Mode</button>
          <button id="mode-simulate">Simulate</button>
        </div>
        <div class="mode-buttons">
          <button id="preset-city">City Grid</button>
          <button id="preset-suburban">Suburban</button>
          <button id="preset-highway">Highway</button>
        </div>
      </div>
      
      <div class="control-group">
        <h3>Traffic Settings</h3>
        <div class="slider-group">
          <label>Spawn Rate:</label>
          <input type="range" id="spawnRate" min="1" max="20" value="5">
          <span class="value-display" id="spawnRateValue">5</span>
        </div>
        <div class="slider-group">
          <label>Max Vehicles:</label>
          <input type="range" id="maxVehicles" min="50" max="500" value="200">
          <span class="value-display" id="maxVehiclesValue">200</span>
        </div>
        <div class="slider-group">
          <label>Vehicle Speed:</label>
          <input type="range" id="vehicleSpeed" min="1" max="10" value="3">
          <span class="value-display" id="vehicleSpeedValue">3</span>
        </div>
      </div>
      
      <div class="control-group">
        <h3>Trail System</h3>
        <div class="slider-group">
          <label>Trail Length:</label>
          <input type="range" id="trailStrength" min="5" max="50" value="20">
          <span class="value-display" id="trailStrengthValue">20</span>
        </div>
        <div class="slider-group">
          <label>Fade Rate:</label>
          <input type="range" id="fadeRate" min="1" max="10" value="5">
          <span class="value-display" id="fadeRateValue">5</span>
        </div>
        <div class="slider-group">
          <label>Trail Influence:</label>
          <input type="range" id="trailInfluence" min="0" max="100" value="30">
          <span class="value-display" id="trailInfluenceValue">30%</span>
        </div>
      </div>
      
      
      <div class="control-group">
        <h3>Controls</h3>
        <button id="pauseBtn">Pause</button>
        <button id="clearTrails">Clear Trails</button>
        <button id="resetBtn">Reset All</button>
        <button id="addVehicles">Add Vehicles</button>
      </div>
    </div>
  </div>

  <script>
    // Canvas setup
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Audio context for sound effects
    let audioContext;
    let soundEnabled = true;
    let masterVolume = 0.5;
    let currentRaga = 'none';
    
    // Raga scales (frequencies in Hz) - 7 notes each
    const ragaScales = {
      Bilawal: [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88], // C major scale
      Yaman: [293.66, 329.63, 369.99, 392.00, 440.00, 493.88, 554.37],   // Lydian mode
      Kalyan: [261.63, 293.66, 329.63, 369.99, 392.00, 440.00, 493.88],  // Major with #4
      Bhairavi: [261.63, 277.18, 311.13, 349.23, 392.00, 415.30, 466.16] // Natural minor
    };
    
    // Vehicle to raga note mapping (each vehicle gets its own note)
    const vehicleRagaMapping = {
      'car': 0,        // 1st note (tonic)
      'truck': 1,      // 2nd note  
      'bus': 2,        // 3rd note
      'bike': 3,       // 4th note
      'emergency': 4,  // 5th note
      'skateboard': 5, // 6th note
      'pedestrian': 6  // 7th note
    };
    
    // Initialize audio context
    function initAudio() {
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      } catch (e) {
        console.log('Audio not supported');
        soundEnabled = false;
      }
    }
    
    // Get raga frequency for vehicle type
    function getRagaFrequency(vehicleType) {
      if (currentRaga === 'none' || !ragaScales[currentRaga]) {
        // Use default frequency if no raga selected
        return vehicleType.sound || 220;
      }
      
      const scale = ragaScales[currentRaga];
      const noteIndex = vehicleRagaMapping[vehicleType.type] || 0;
      return scale[noteIndex] || 220;
    }
    
    // Enhanced sound generation with raga support
    function playEngineSound(frequencyOrVehicleType = 80, duration = 0.1) {
      if (!soundEnabled || !audioContext) return;
      
      // Handle both old frequency parameter and new vehicleType parameter
      let frequency;
      let vehicleType = null;
      if (typeof frequencyOrVehicleType === 'object' && frequencyOrVehicleType.type) {
        // New vehicleType object - use raga frequency
        vehicleType = frequencyOrVehicleType;
        frequency = getRagaFrequency(vehicleType);
      } else if (typeof frequencyOrVehicleType === 'number') {
        // Old frequency parameter
        frequency = frequencyOrVehicleType;
      } else {
        // Fallback
        frequency = 220;
      }
      
      // Validate frequency
      if (!isFinite(frequency) || frequency <= 0) {
        frequency = 220; // Safe fallback
      }
      
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
      
      // Different waveforms for different vehicle types
      if (vehicleType) {
        switch(vehicleType.type) {
          case 'car':
            oscillator.type = 'sine';
            break;
          case 'truck':
            oscillator.type = 'sawtooth';
            break;
          case 'bus':
            oscillator.type = 'square';
            break;
          case 'bike':
            oscillator.type = 'triangle';
            break;
          case 'emergency':
            oscillator.type = 'sine';
            // Add vibrato for emergency vehicles
            const vibrato = audioContext.createOscillator();
            const vibratoGain = audioContext.createGain();
            vibrato.frequency.setValueAtTime(6, audioContext.currentTime);
            vibratoGain.gain.setValueAtTime(8, audioContext.currentTime);
            vibrato.connect(vibratoGain);
            vibratoGain.connect(oscillator.frequency);
            vibrato.start(audioContext.currentTime);
            vibrato.stop(audioContext.currentTime + duration);
            break;
          case 'skateboard':
            oscillator.type = 'triangle';
            break;
          case 'pedestrian':
            oscillator.type = 'sine';
            break;
          default:
            oscillator.type = 'sine';
        }
      } else {
        oscillator.type = 'sawtooth';
      }
      
      gainNode.gain.setValueAtTime(0, audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(masterVolume * 0.1, audioContext.currentTime + 0.01);
      gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + duration);
    }
    
    function playHornSound(vehicleType) {
      if (!soundEnabled || !audioContext) return;
      
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      // Use raga frequencies for horn sounds too
      const baseFreq = getRagaFrequency(vehicleType);
      const highFreq = baseFreq * 1.5; // Perfect fifth interval
      
      oscillator.frequency.setValueAtTime(baseFreq, audioContext.currentTime);
      oscillator.frequency.linearRampToValueAtTime(highFreq, audioContext.currentTime + 0.3);
      oscillator.type = 'square';
      
      gainNode.gain.setValueAtTime(0, audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(masterVolume * 0.25, audioContext.currentTime + 0.05);
      gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.3);
    }
    
    // Simulation state
    let vehicles = [];
    let destinations = [];
    let trafficLights = [];
    let roads = [];
    let intersections = [];
    let isRunning = true;
    let buildMode = true;
    let roadWidth = 30;
    let spawnRate = 5;
    let maxVehicles = 200;
    let darkTheme = true; // Keep dark theme always on
    
    // Cursor control
    let cursorX = 0;
    let cursorY = 0;
    let keys = {};
    
    // Vehicle types and colors (7 vehicles = 7 notes per raga)
    const vehicleTypes = [
      { type: 'car', color: '#ff4444', size: 2, speed: 5.0, sound: 100 },
      { type: 'truck', color: '#4444ff', size: 3, speed: 2.8, sound: 80 },
      { type: 'bus', color: '#ffff44', size: 4, speed: 3.6, sound: 70 },
      { type: 'bike', color: '#44ff44', size: 1, speed: 1.3, sound: 150 },
      { type: 'emergency', color: '#ff44ff', size: 2, speed: 8.5, sound: 200 },
      { type: 'skateboard', color: '#ff8844', size: 1, speed: 1.8, sound: 250 },
      { type: 'pedestrian', color: '#8844ff', size: 1, speed: 0.4, sound: 300 }
    ];
    
    // Parameters
    let vehicleSpeed = 8;
    let trailLength = 20;
    let fadeRate = 5;
    let trailInfluence = 0.3;
    
    // Road segment class
    class Road {
      constructor(startX, startY, endX, endY, width = 30) {
        this.startX = startX;
        this.startY = startY;
        this.endX = endX;
        this.endY = endY;
        this.width = width;
        this.id = Math.random().toString(36).substr(2, 9);
        this.speedLimit = 35; // mph
        this.lanes = 2; // number of lanes
        
        // Calculate road properties for geometry
        this.length = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
        this.angle = Math.atan2(endY - startY, endX - startX);
        this.direction = { x: (endX - startX) / this.length, y: (endY - startY) / this.length };
        this.perpendicular = { x: -this.direction.y, y: this.direction.x };
      }
      
      draw() {
        // Draw road surface (asphalt)
        ctx.strokeStyle = '#404040'; // Dark asphalt
        ctx.lineWidth = this.width;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(this.startX, this.startY);
        ctx.lineTo(this.endX, this.endY);
        ctx.stroke();
        
        // Draw road edges (solid white lines)
        this.drawRoadEdges();
        
        // Draw center line (double solid yellow)
        this.drawCenterLine();
      }
      
      drawRoadEdges() {
        const angle = Math.atan2(this.endY - this.startY, this.endX - this.startX);
        const perpAngle = angle + Math.PI / 2;
        const edgeOffset = this.width / 2;
        
        // Calculate edge line points
        const edge1StartX = this.startX + Math.cos(perpAngle) * edgeOffset;
        const edge1StartY = this.startY + Math.sin(perpAngle) * edgeOffset;
        const edge1EndX = this.endX + Math.cos(perpAngle) * edgeOffset;
        const edge1EndY = this.endY + Math.sin(perpAngle) * edgeOffset;
        
        const edge2StartX = this.startX - Math.cos(perpAngle) * edgeOffset;
        const edge2StartY = this.startY - Math.sin(perpAngle) * edgeOffset;
        const edge2EndX = this.endX - Math.cos(perpAngle) * edgeOffset;
        const edge2EndY = this.endY - Math.sin(perpAngle) * edgeOffset;
        
        // Draw solid white edge lines
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.lineCap = 'butt';
        
        // Edge 1
        ctx.beginPath();
        ctx.moveTo(edge1StartX, edge1StartY);
        ctx.lineTo(edge1EndX, edge1EndY);
        ctx.stroke();
        
        // Edge 2
        ctx.beginPath();
        ctx.moveTo(edge2StartX, edge2StartY);
        ctx.lineTo(edge2EndX, edge2EndY);
        ctx.stroke();
      }
      
      drawCenterLine() {
        // Double solid yellow center line
        const angle = Math.atan2(this.endY - this.startY, this.endX - this.startX);
        const perpAngle = angle + Math.PI / 2;
        const lineSpacing = 2; // Space between the two yellow lines
        
        // Calculate center line positions
        const line1StartX = this.startX + Math.cos(perpAngle) * lineSpacing / 2;
        const line1StartY = this.startY + Math.sin(perpAngle) * lineSpacing / 2;
        const line1EndX = this.endX + Math.cos(perpAngle) * lineSpacing / 2;
        const line1EndY = this.endY + Math.sin(perpAngle) * lineSpacing / 2;
        
        const line2StartX = this.startX - Math.cos(perpAngle) * lineSpacing / 2;
        const line2StartY = this.startY - Math.sin(perpAngle) * lineSpacing / 2;
        const line2EndX = this.endX - Math.cos(perpAngle) * lineSpacing / 2;
        const line2EndY = this.endY - Math.sin(perpAngle) * lineSpacing / 2;
        
        // Draw double solid yellow lines
        ctx.strokeStyle = '#ffff00';
        ctx.lineWidth = 1.5;
        ctx.lineCap = 'butt';
        
        // Yellow line 1
        ctx.beginPath();
        ctx.moveTo(line1StartX, line1StartY);
        ctx.lineTo(line1EndX, line1EndY);
        ctx.stroke();
        
        // Yellow line 2
        ctx.beginPath();
        ctx.moveTo(line2StartX, line2StartY);
        ctx.lineTo(line2EndX, line2EndY);
        ctx.stroke();
      }
      
      // Get the closest point on this road to a given point
      getClosestPointOnRoad(x, y) {
        const dx = x - this.startX;
        const dy = y - this.startY;
        
        // Project point onto road direction vector
        const projection = (dx * this.direction.x + dy * this.direction.y);
        const t = Math.max(0, Math.min(this.length, projection));
        
        const closestX = this.startX + t * this.direction.x;
        const closestY = this.startY + t * this.direction.y;
        const distance = Math.sqrt((x - closestX) ** 2 + (y - closestY) ** 2);
        
        return {
          x: closestX,
          y: closestY,
          t: t / this.length, // normalized position along road (0-1)
          distance: distance
        };
      }
      
      // Get distance from point to road
      getDistanceToRoad(x, y) {
        const dx = x - this.startX;
        const dy = y - this.startY;
        
        // Project point onto road direction vector
        const projection = (dx * this.direction.x + dy * this.direction.y);
        const t = Math.max(0, Math.min(this.length, projection));
        
        const closestX = this.startX + t * this.direction.x;
        const closestY = this.startY + t * this.direction.y;
        
        return Math.sqrt((x - closestX) ** 2 + (y - closestY) ** 2);
      }
      
      // Check if point is on this road (within road width)
      isPointOnRoad(x, y, tolerance = 5) {
        return this.getDistanceToRoad(x, y) <= (this.width / 2 + tolerance);
      }
      
      // Get position at specific distance along road
      getPositionAtDistance(distance) {
        const t = distance / this.length;
        return {
          x: this.startX + t * (this.endX - this.startX),
          y: this.startY + t * (this.endY - this.startY),
          angle: this.angle
        };
      }
      
      // Get lane position (offset from center line)
      getLanePosition(t, laneOffset = 0) {
        const centerX = this.startX + t * (this.endX - this.startX);
        const centerY = this.startY + t * (this.endY - this.startY);
        
        // Offset by lane position (positive = right side, negative = left side)
        const offsetDistance = laneOffset * (this.width / 4); // quarter width per lane
        
        return {
          x: centerX + this.perpendicular.x * offsetDistance,
          y: centerY + this.perpendicular.y * offsetDistance,
          angle: this.angle
        };
      }
      
      // Find intersections with other roads
      getIntersectionWith(otherRoad) {
        const x1 = this.startX, y1 = this.startY;
        const x2 = this.endX, y2 = this.endY;
        const x3 = otherRoad.startX, y3 = otherRoad.startY;
        const x4 = otherRoad.endX, y4 = otherRoad.endY;
        
        const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (Math.abs(denom) < 0.0001) return null; // Parallel lines
        
        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
        
        if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
          return {
            x: x1 + t * (x2 - x1),
            y: y1 + t * (y2 - y1),
            t1: t, // position on this road
            t2: u  // position on other road
          };
        }
        
        return null;
      }
    }
    
    function resizeCanvas() {
      const container = document.querySelector('.simulation-view');
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      
      // Initialize with a simple road network
      if (roads.length === 0) {
        initializeDefaultRoadNetwork();
      }
    }
    
    // Initialize with a basic road network
    function initializeDefaultRoadNetwork() {
      roads = [];
      
      // Create a simple grid of roads
      const roadSpacing = 150;
      const margin = 50;
      
      // Horizontal roads
      for (let y = margin; y < canvas.height - margin; y += roadSpacing) {
        roads.push(new Road(margin, y, canvas.width - margin, y, roadWidth));
      }
      
      // Vertical roads
      for (let x = margin; x < canvas.width - margin; x += roadSpacing) {
        roads.push(new Road(x, margin, x, canvas.height - margin, roadWidth));
      }
      
      console.log(`Initialized ${roads.length} road segments`);
      
      // Find intersections after creating roads
      findRoadIntersections();
    }
    
    // Draw road network with proper intersections
    function drawRoadNetwork() {
      // First pass: Draw all road surfaces
      roads.forEach(road => {
        ctx.strokeStyle = '#404040'; // Dark asphalt
        ctx.lineWidth = road.width;
        ctx.lineCap = 'square'; // Square caps for clean intersections
        ctx.beginPath();
        ctx.moveTo(road.startX, road.startY);
        ctx.lineTo(road.endX, road.endY);
        ctx.stroke();
      });
      
      // Second pass: Draw intersection areas
      intersections.forEach(intersection => {
        const size = roadWidth;
        ctx.fillStyle = '#404040'; // Match road surface
        ctx.fillRect(
          intersection.point.x - size/2, 
          intersection.point.y - size/2, 
          size, 
          size
        );
      });
      
      // Third pass: Draw road markings
      roads.forEach(road => {
        drawRoadMarkings(road);
      });
    }
    
    // Draw road markings (edges and center lines)
    function drawRoadMarkings(road) {
      const angle = Math.atan2(road.endY - road.startY, road.endX - road.startX);
      const perpAngle = angle + Math.PI / 2;
      const edgeOffset = road.width / 2;
      
      // Calculate line positions
      // For right-hand traffic: yellow center line, white edge lines
      const rightEdgeStartX = road.startX + Math.cos(perpAngle) * edgeOffset;
      const rightEdgeStartY = road.startY + Math.sin(perpAngle) * edgeOffset;
      const rightEdgeEndX = road.endX + Math.cos(perpAngle) * edgeOffset;
      const rightEdgeEndY = road.endY + Math.sin(perpAngle) * edgeOffset;
      
      const leftEdgeStartX = road.startX - Math.cos(perpAngle) * edgeOffset;
      const leftEdgeStartY = road.startY - Math.sin(perpAngle) * edgeOffset;
      const leftEdgeEndX = road.endX - Math.cos(perpAngle) * edgeOffset;
      const leftEdgeEndY = road.endY - Math.sin(perpAngle) * edgeOffset;
      
      // Draw faded white edge lines (road boundaries)
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; // 30% opacity white
      ctx.lineWidth = 1.5;
      ctx.lineCap = 'butt';
      
      // Right edge (faded white)
      drawLineWithIntersectionBreaks(rightEdgeStartX, rightEdgeStartY, rightEdgeEndX, rightEdgeEndY, road);
      
      // Left edge (faded white)
      drawLineWithIntersectionBreaks(leftEdgeStartX, leftEdgeStartY, leftEdgeEndX, leftEdgeEndY, road);
      
      // Draw faded center line (yellow) - separates opposing traffic
      ctx.strokeStyle = 'rgba(255, 255, 0, 0.4)'; // 40% opacity yellow
      ctx.lineWidth = 1.5;
      drawLineWithIntersectionBreaks(road.startX, road.startY, road.endX, road.endY, road);
    }
    
    // Draw line segments, breaking at intersections
    function drawLineWithIntersectionBreaks(startX, startY, endX, endY, road) {
      const roadIntersections = intersections.filter(int => 
        int.road1 === road || int.road2 === road
      ).sort((a, b) => {
        // Sort by position along the road
        const t1 = a.road1 === road ? a.road1Position : a.road2Position;
        const t2 = b.road1 === road ? b.road1Position : b.road2Position;
        return t1 - t2;
      });
      
      if (roadIntersections.length === 0) {
        // No intersections, draw full line
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        return;
      }
      
      let lastT = 0;
      const breakSize = roadWidth / 2; // Size of break around intersection
      
      roadIntersections.forEach(intersection => {
        const t = intersection.road1 === road ? intersection.road1Position : intersection.road2Position;
        const breakStart = Math.max(lastT, t - breakSize / road.length);
        const breakEnd = Math.min(1, t + breakSize / road.length);
        
        // Draw segment before intersection
        if (breakStart > lastT) {
          const segStartX = startX + (endX - startX) * lastT;
          const segStartY = startY + (endY - startY) * lastT;
          const segEndX = startX + (endX - startX) * breakStart;
          const segEndY = startY + (endY - startY) * breakStart;
          
          ctx.beginPath();
          ctx.moveTo(segStartX, segStartY);
          ctx.lineTo(segEndX, segEndY);
          ctx.stroke();
        }
        
        lastT = breakEnd;
      });
      
      // Draw final segment
      if (lastT < 1) {
        const segStartX = startX + (endX - startX) * lastT;
        const segStartY = startY + (endY - startY) * lastT;
        
        ctx.beginPath();
        ctx.moveTo(segStartX, segStartY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
      }
    }
    
    // Draw all roads
    function drawRoads() {
      roads.forEach(road => road.draw());
    }
    
    // Find the closest road to a point
    function findNearestRoad(x, y) {
      let nearestRoad = null;
      let minDistance = Infinity;
      
      for (const road of roads) {
        const distance = road.getDistanceToRoad(x, y);
        if (distance < minDistance) {
          minDistance = distance;
          nearestRoad = road;
        }
      }
      
      return nearestRoad;
    }
    
    // Find all intersections in the road network
    function findRoadIntersections() {
      intersections = [];
      
      for (let i = 0; i < roads.length; i++) {
        for (let j = i + 1; j < roads.length; j++) {
          const intersection = roads[i].getIntersectionWith(roads[j]);
          if (intersection) {
            intersections.push({
              point: intersection,
              road1: roads[i],
              road2: roads[j],
              road1Position: intersection.t1,
              road2Position: intersection.t2
            });
          }
        }
      }
      
      console.log(`Found ${intersections.length} intersections`);
      return intersections;
    }
    
    // Road-following Vehicle class
    class RoadVehicle {
      constructor(x, y, destination) {
        this.x = x;
        this.y = y;
        this.destination = destination;
        this.currentRoad = null;
        this.roadPosition = 0; // Position along current road (0-1)
        this.laneOffset = 0.25 + (Math.random() - 0.5) * 0.1; // Center of right lane with slight variation
        this.speed = vehicleSpeed;
        this.angle = 0;
        this.type = vehicleTypes[Math.floor(Math.random() * vehicleTypes.length)];
        this.lastSoundTime = 0;
        this.trail = [];
        this.maxTrailLength = trailLength;
        this.path = []; // Array of roads to follow
        this.pathIndex = 0;
        this.atIntersection = false;
        
        // Find initial road and snap to it
        this.snapToNearestRoad();
        
        // Find path to destination
        this.findPathToDestination();
      }
      
      snapToNearestRoad() {
        this.currentRoad = findNearestRoad(this.x, this.y);
        if (this.currentRoad) {
          const closestPoint = this.currentRoad.getClosestPointOnRoad(this.x, this.y);
          const lanePosition = this.currentRoad.getLanePosition(closestPoint.t, this.laneOffset);
          this.x = lanePosition.x;
          this.y = lanePosition.y;
          this.roadPosition = closestPoint.t;
          this.angle = this.currentRoad.angle;
        }
      }
      
      findPathToDestination() {
        if (!this.currentRoad || !this.destination) return;
        
        // Simple pathfinding: find destination road and navigate through intersections
        const destRoad = findNearestRoad(this.destination.x, this.destination.y);
        if (!destRoad) return;
        
        if (destRoad === this.currentRoad) {
          // Same road, just move along it
          this.path = [this.currentRoad];
        } else {
          // Different road, need to find path through intersections
          this.path = this.findRoadPath(this.currentRoad, destRoad);
        }
      }
      
      findRoadPath(startRoad, endRoad) {
        // Simple breadth-first search through road network
        const visited = new Set();
        const queue = [[startRoad]];
        
        while (queue.length > 0) {
          const path = queue.shift();
          const currentRoad = path[path.length - 1];
          
          if (currentRoad === endRoad) {
            return path;
          }
          
          if (visited.has(currentRoad.id)) continue;
          visited.add(currentRoad.id);
          
          // Find connected roads through intersections
          for (const intersection of intersections) {
            let nextRoad = null;
            if (intersection.road1 === currentRoad) {
              nextRoad = intersection.road2;
            } else if (intersection.road2 === currentRoad) {
              nextRoad = intersection.road1;
            }
            
            if (nextRoad && !visited.has(nextRoad.id)) {
              queue.push([...path, nextRoad]);
            }
          }
        }
        
        return [startRoad]; // Fallback to current road
      }
      
      update() {
        if (!this.currentRoad) return false;
        
        // Calculate movement direction
        let direction = 1; // Forward along road
        
        // If we have a path, follow it
        if (this.path.length > this.pathIndex) {
          const targetRoad = this.path[this.pathIndex];
          
          if (targetRoad !== this.currentRoad) {
            // Need to switch roads at intersection
            this.switchToRoad(targetRoad);
          } else {
            // Move along current road
            this.moveAlongRoad(direction);
          }
        } else {
          // No path, just move along current road
          this.moveAlongRoad(direction);
        }
        
        // Update trail
        this.updateTrail();
        
        // Play engine sound occasionally
        if (Date.now() - this.lastSoundTime > 3000 + Math.random() * 4000) {
          playEngineSound(this.type, 0.2 + Math.random() * 0.3);
          this.lastSoundTime = Date.now();
        }
        
        // Check if reached destination
        if (this.destination) {
          const dx = this.x - this.destination.x;
          const dy = this.y - this.destination.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < 20) {
            return false; // Remove vehicle
          }
        }
        
        return true;
      }
      
      moveAlongRoad(direction) {
        const moveSpeed = this.speed * this.type.speed * 0.02;
        const deltaPosition = (moveSpeed / this.currentRoad.length) * direction;
        
        this.roadPosition += deltaPosition;
        
        // Check if reached end of road
        if (this.roadPosition >= 1.0) {
          this.roadPosition = 1.0;
          this.pathIndex++;
        } else if (this.roadPosition <= 0.0) {
          this.roadPosition = 0.0;
          this.pathIndex++;
        }
        
        // Update actual position based on road position
        const lanePosition = this.currentRoad.getLanePosition(this.roadPosition, this.laneOffset);
        this.x = lanePosition.x;
        this.y = lanePosition.y;
        this.angle = this.currentRoad.angle;
      }
      
      switchToRoad(newRoad) {
        // Find intersection between current and new road
        const intersection = this.currentRoad.getIntersectionWith(newRoad);
        if (intersection) {
          this.currentRoad = newRoad;
          this.roadPosition = intersection.t2;
          this.pathIndex++;
          
          // Update position
          const lanePosition = this.currentRoad.getLanePosition(this.roadPosition, this.laneOffset);
          this.x = lanePosition.x;
          this.y = lanePosition.y;
          this.angle = this.currentRoad.angle;
        }
      }
      
      updateTrail() {
        // Add current position to trail
        this.trail.push({ x: this.x, y: this.y, alpha: 1.0 });
        
        // Update max trail length from global setting
        this.maxTrailLength = trailLength;
        
        // Limit trail length
        if (this.trail.length > this.maxTrailLength) {
          this.trail.shift();
        }
        
        // Fade trail points
        this.trail.forEach((point, index) => {
          point.alpha = (index / this.trail.length) * (fadeRate / 10);
        });
      }
      
      draw() {
        // Draw trail first (behind vehicle)
        this.drawTrail();
        
        // Vehicle body
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        // Double the vehicle size for better visibility
        const vehicleWidth = this.type.size * 8; // was * 4
        const vehicleHeight = this.type.size * 4; // was * 2
        
        ctx.fillStyle = this.type.color;
        ctx.fillRect(-vehicleWidth/2, -vehicleHeight/2, vehicleWidth, vehicleHeight);
        
        // Headlights (always on for dark theme) - scaled proportionally
        ctx.fillStyle = '#ffffff';
        const headlightWidth = 3;
        const headlightHeight = vehicleHeight * 0.3;
        ctx.fillRect(vehicleWidth/2, -headlightHeight/2 - vehicleHeight * 0.1, headlightWidth, headlightHeight);
        ctx.fillRect(vehicleWidth/2, headlightHeight/2 + vehicleHeight * 0.1 - headlightHeight, headlightWidth, headlightHeight);
        
        ctx.restore();
      }
      
      drawTrail() {
        if (this.trail.length < 2) return;
        
        // Draw trail as connected line segments
        ctx.strokeStyle = this.type.color;
        ctx.lineWidth = this.type.size;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        for (let i = 1; i < this.trail.length; i++) {
          const point = this.trail[i];
          const prevPoint = this.trail[i - 1];
          
          // Set alpha based on trail position
          const alpha = point.alpha;
          const color = this.type.color;
          
          // Convert color to rgba with alpha
          if (color.startsWith('#')) {
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
          } else {
            ctx.strokeStyle = color;
          }
          
          ctx.globalAlpha = alpha;
          ctx.beginPath();
          ctx.moveTo(prevPoint.x, prevPoint.y);
          ctx.lineTo(point.x, point.y);
          ctx.stroke();
        }
        
        ctx.globalAlpha = 1.0;
      }
    }
    
    // Traffic Light class
    class TrafficLight {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.state = 'green'; // green, yellow, red
        this.timer = 0;
        this.greenDuration = 180; // 3 seconds
        this.yellowDuration = 60; // 1 second
        this.redDuration = 120; // 2 seconds
      }
      
      update() {
        this.timer++;
        
        switch (this.state) {
          case 'green':
            if (this.timer > this.greenDuration) {
              this.state = 'yellow';
              this.timer = 0;
            }
            break;
          case 'yellow':
            if (this.timer > this.yellowDuration) {
              this.state = 'red';
              this.timer = 0;
            }
            break;
          case 'red':
            if (this.timer > this.redDuration) {
              this.state = 'green';
              this.timer = 0;
            }
            break;
        }
      }
      
      draw() {
        // Traffic light post
        ctx.fillStyle = '#333333';
        ctx.fillRect(this.x - 2, this.y - 10, 4, 20);
        
        // Light colors
        const colors = {
          green: this.state === 'green' ? '#00ff00' : '#003300',
          yellow: this.state === 'yellow' ? '#ffff00' : '#333300',
          red: this.state === 'red' ? '#ff0000' : '#330000'
        };
        
        // Draw lights
        ctx.fillStyle = colors.red;
        ctx.beginPath();
        ctx.arc(this.x, this.y - 8, 3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = colors.yellow;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = colors.green;
        ctx.beginPath();
        ctx.arc(this.x, this.y + 8, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    // Spawn road vehicle
    function spawnRoadVehicle() {
      if (vehicles.length >= maxVehicles || destinations.length === 0 || roads.length === 0) return;
      
      // Pick a random road and position along it
      const road = roads[Math.floor(Math.random() * roads.length)];
      const t = Math.random(); // Random position along road
      const laneOffset = (Math.random() - 0.5) * 0.5; // Random lane
      const position = road.getLanePosition(t, laneOffset);
      
      // Pick random destination
      const destination = destinations[Math.floor(Math.random() * destinations.length)];
      
      const vehicle = new RoadVehicle(position.x, position.y, destination);
      vehicles.push(vehicle);
    }
    
    // Draw cursor on canvas
    function drawCursor() {
      const size = buildMode ? roadWidth : 20;
      const x = cursorX;
      const y = cursorY;
      
      // Draw cursor border
      ctx.strokeStyle = '#ff6b35';
      ctx.lineWidth = 3;
      ctx.setLineDash([5, 5]); // Dashed line for visibility
      ctx.strokeRect(x - size/2, y - size/2, size, size);
      
      // Draw cursor fill
      ctx.fillStyle = 'rgba(255, 107, 53, 0.2)';
      ctx.fillRect(x - size/2, y - size/2, size, size);
      
      // Reset line dash
      ctx.setLineDash([]);
    }
    
    // Initialize cursor
    function initializeCursor() {
      cursorX = canvas.width / 2;
      cursorY = canvas.height / 2;
      updateCursorDisplay();
    }
    
    // Update cursor display (now just updates text)
    function updateCursorDisplay() {
      document.getElementById('cursorPos').textContent = `${Math.round(cursorX)}, ${Math.round(cursorY)}`;
    }
    
    // Handle single arrow key press movement
    let lastKeyPress = {};
    
    function handleArrowKeyPress(key) {
      const now = Date.now();
      const moveDistance = buildMode ? 10 : 5;
      
      // Only move if this is a new key press (not held down)
      if (!lastKeyPress[key] || now - lastKeyPress[key] > 150) {
        let moved = false;
        
        if (key === 'arrowup') {
          cursorY = Math.max(0, cursorY - moveDistance);
          moved = true;
        } else if (key === 'arrowdown') {
          cursorY = Math.min(canvas.height, cursorY + moveDistance);
          moved = true;
        } else if (key === 'arrowleft') {
          cursorX = Math.max(0, cursorX - moveDistance);
          moved = true;
        } else if (key === 'arrowright') {
          cursorX = Math.min(canvas.width, cursorX + moveDistance);
          moved = true;
        }
        
        if (moved) {
          updateCursorDisplay();
          lastKeyPress[key] = now;
        }
      }
    }
    
    // Update statistics
    function updateStats() {
      document.getElementById('vehicleCount').textContent = vehicles.length;
      document.getElementById('destinationCount').textContent = destinations.length;
      document.getElementById('trafficLightCount').textContent = trafficLights.length;
      document.getElementById('roadCount').textContent = roads.length;
      
      // Calculate traffic density (placeholder)
      const density = Math.min(100, (vehicles.length / maxVehicles) * 100);
      document.getElementById('trafficDensity').textContent = density.toFixed(1) + '%';
      
      // Calculate average speed (placeholder)
      const avgSpeed = vehicles.length > 0 ? 
        vehicles.reduce((sum, v) => sum + (v.speed || vehicleSpeed), 0) / vehicles.length : 0;
      document.getElementById('avgSpeed').textContent = (avgSpeed * 10).toFixed(1) + ' mph';
    }
    
    
    // Input handling
    function setupControls() {
      // Sliders
      const sliders = [
        { id: 'spawnRate', prop: 'spawnRate', display: 'spawnRateValue' },
        { id: 'maxVehicles', prop: 'maxVehicles', display: 'maxVehiclesValue' },
        { id: 'vehicleSpeed', prop: 'vehicleSpeed', display: 'vehicleSpeedValue' },
        { id: 'roadWidth', prop: 'roadWidth', display: 'roadWidthValue' },
        { id: 'trailStrength', prop: 'trailLength', display: 'trailStrengthValue' },
        { id: 'fadeRate', prop: 'fadeRate', display: 'fadeRateValue' },
        { id: 'trailInfluence', prop: 'trailInfluence', display: 'trailInfluenceValue', convert: v => v/100 },
        { id: 'soundVolume', prop: 'masterVolume', display: 'soundVolumeValue', convert: v => v/100, format: v => v + '%' }
      ];
      
      sliders.forEach(slider => {
        const element = document.getElementById(slider.id);
        const display = document.getElementById(slider.display);
        
        element.addEventListener('input', () => {
          const value = parseFloat(element.value);
          window[slider.prop] = slider.convert ? slider.convert(value) : value;
          display.textContent = slider.format ? slider.format(value) : value;
        });
        
        display.textContent = slider.format ? slider.format(element.value) : element.value;
      });
      
      // Mode buttons
      document.getElementById('mode-build').addEventListener('click', () => {
        buildMode = true;
        updateModeButtons();
      });
      
      document.getElementById('mode-simulate').addEventListener('click', () => {
        buildMode = false;
        updateModeButtons();
      });
      
      
      // Control buttons
      document.getElementById('pauseBtn').addEventListener('click', () => {
        isRunning = !isRunning;
        document.getElementById('pauseBtn').textContent = isRunning ? 'Pause' : 'Resume';
      });
      
      document.getElementById('clearTrails').addEventListener('click', () => {
        // Clear trails functionality will be implemented
      });
      
      document.getElementById('resetBtn').addEventListener('click', () => {
        vehicles = [];
        destinations = [];
        trafficLights = [];
        roads = [];
        initializeDefaultRoadNetwork();
      });
      
      document.getElementById('addVehicles').addEventListener('click', () => {
        for (let i = 0; i < 10; i++) {
          spawnRoadVehicle();
        }
      });
      
      // Sound toggle button
      document.getElementById('soundToggle').addEventListener('click', () => {
        soundEnabled = !soundEnabled;
        const btn = document.getElementById('soundToggle');
        btn.textContent = soundEnabled ? 'üîä Sound On' : 'üîá Sound Off';
        btn.classList.toggle('active', soundEnabled);
      });
      
      // Raga selection
      document.getElementById('ragaSelect').addEventListener('change', (e) => {
        currentRaga = e.target.value;
        console.log(`Raga changed to: ${currentRaga}`);
      });
      
      // Preset buttons
      document.getElementById('preset-city').addEventListener('click', () => {
        initializeDefaultRoadNetwork();
      });
      
      document.getElementById('preset-suburban').addEventListener('click', () => {
        // Suburban preset will be implemented
        console.log('Suburban preset not yet implemented');
      });
      
      document.getElementById('preset-highway').addEventListener('click', () => {
        // Highway preset will be implemented
        console.log('Highway preset not yet implemented');
      });
    }
    
    function updateModeButtons() {
      // Update build/simulate mode
      document.querySelectorAll('[id^="mode-build"], [id^="mode-simulate"]').forEach(btn => btn.classList.remove('active'));
      if (buildMode) {
        document.getElementById('mode-build').classList.add('active');
      } else {
        document.getElementById('mode-simulate').classList.add('active');
      }
      
    }
    
    // Keyboard controls
    window.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();
      keys[key] = true;
      
      if (['d', 't', 'r', 'v', ' ', 's', 'c', 'escape', 'p', 'n', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(key)) {
        e.preventDefault();
      }
      
      // Handle arrow key movement immediately on keydown
      if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(key)) {
        handleArrowKeyPress(key);
        return;
      }
      
      if (key === 'd') {
        // Add destination at cursor
        destinations.push({
          x: cursorX,
          y: cursorY
        });
      } else if (key === 't') {
        // Add traffic light at cursor
        trafficLights.push(new TrafficLight(cursorX, cursorY));
      } else if (key === 'r') {
        // Road building mode toggle
        buildMode = !buildMode;
        updateModeButtons();
      } else if (key === 'v') {
        // Add vehicles
        for (let i = 0; i < 10; i++) {
          spawnRoadVehicle();
        }
      } else if (key === 's') {
        // Toggle sound
        soundEnabled = !soundEnabled;
        const btn = document.getElementById('soundToggle');
        btn.textContent = soundEnabled ? 'üîä Sound On' : 'üîá Sound Off';
        btn.classList.toggle('active', soundEnabled);
      } else if (key === 'c') {
        // Clear trails (placeholder)
        console.log('Clear trails not yet implemented');
      } else if (key === 'escape') {
        vehicles = [];
        destinations = [];
        trafficLights = [];
        roads = [];
        initializeDefaultRoadNetwork();
      } else if (key === 'p') {
        isRunning = !isRunning;
        document.getElementById('pauseBtn').textContent = isRunning ? 'Pause' : 'Resume';
      }
    });
    
    window.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
    });
    
    // Animation loop
    function animate() {
      if (isRunning) {
        // Spawn vehicles
        if (Math.random() < spawnRate / 1000) {
          spawnRoadVehicle();
        }
        
        // Update vehicles
        vehicles = vehicles.filter(vehicle => vehicle.update());
        
        // Update traffic lights
        trafficLights.forEach(light => light.update());
        
        // Update statistics
        updateStats();
      }
      
      // Clear canvas with dark ground color
      ctx.fillStyle = '#1a2a1a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw roads with proper intersections
      drawRoadNetwork();
      
      // Draw destinations (placeholder)
      destinations.forEach((dest, index) => {
        ctx.fillStyle = '#00ffff';
        ctx.beginPath();
        ctx.arc(dest.x, dest.y, 10, 0, Math.PI * 2);
        ctx.fill();
      });
      
      // Draw traffic lights
      trafficLights.forEach(light => light.draw());
      
      // Draw vehicles
      vehicles.forEach(vehicle => vehicle.draw());
      
      // Draw cursor
      drawCursor();
      
      requestAnimationFrame(animate);
    }
    
    // Initialize
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    initAudio();
    setupControls();
    initializeCursor();
    
    // Start simulation
    animate();
  </script>
</body>
</html>