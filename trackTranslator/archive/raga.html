<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Explosion Simulation with Organized Raga Tones</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: rgb(33, 33, 33);
      color: white;
      font-family: Arial, sans-serif;
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
      background-color: black;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
    }
    select, button, input[type="range"] {
      padding: 5px;
      background-color: #4CAF50;
      color: white;
      border: none;
      cursor: pointer;
    }
    button {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    #muteIcon {
      font-size: 18px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label for="explosionSelect">Explosion Type:</label>
    <select id="explosionSelect" onchange="setExplosionType(this.value)">
      <option value="field">Field Explosion</option>
      <option value="blob">Blob Explosion</option>
      <option value="wave">Wave Explosion</option>
      <option value="hybrid">Hybrid Explosion</option>
    </select>
    
    <label for="soundSelect">Sound Type:</label>
    <!-- Although the dropdown exists for manual selection, auto-trigger always uses oscillator sound -->
    <select id="soundSelect">
      <option value="oscillator" selected>Oscillator Sound</option>
      <option value="procedural">Procedural Sound</option>
      <option value="buffer">Custom Buffer Sound</option>
      <option value="jazz">Smooth Jazz</option>
    </select>
    
    <!-- New Raga dropdown for organized tones -->
    <label for="ragaSelect">Raga:</label>
    <select id="ragaSelect">
      <option value="none" selected>None</option>
      <option value="Bilawal">Bilawal</option>
      <option value="Yaman">Yaman</option>
      <option value="Kalyan">Kalyan</option>
      <option value="Bhairavi">Bhairavi</option>
    </select>
    
    <!-- Speed slider -->
    <label for="speedSlider">Speed:</label>
    <input type="range" id="speedSlider" min="0.5" max="30" step="0.5" value="3" />
    
    <!-- Mute Toggle Button -->
    <button id="muteToggle" onclick="toggleMute()">
      <span id="muteIcon">ðŸ”‡</span>
      <span id="muteLabel">Muted</span>
    </button>
  </div>
  
  <canvas id="explosionCanvas"></canvas>
  
  <!-- Hidden audio element for smooth jazz (preloaded, looped) -->
  <audio id="jazzAudio" src="path/to/your/smooth_jazz.mp3" loop></audio>
  
  <script>
    // Global mute flag
    let isMuted = true;
    // Auto-trigger interval variable (milliseconds)
    let autoTriggerInterval = 1500;
    let autoTriggerHandle = null;
    // Speed multiplier from the slider (default 1)
    let speedMultiplier = 1;
    
    // Update auto-trigger interval based on slider value.
    const speedSlider = document.getElementById('speedSlider');
    speedSlider.addEventListener('input', () => {
      speedMultiplier = parseFloat(speedSlider.value);
      // Higher speed => shorter interval
      autoTriggerInterval = 1500 / speedMultiplier;
      restartAutoTrigger();
    });
    
    // Restart auto-trigger interval.
    function restartAutoTrigger() {
      if (autoTriggerHandle) clearInterval(autoTriggerHandle);
      autoTriggerHandle = setInterval(autoTrigger, autoTriggerInterval);
    }
    // Start auto-trigger.
    restartAutoTrigger();
    
    // Toggle mute state.
    function toggleMute() {
      isMuted = !isMuted;
      document.getElementById('muteIcon').textContent = isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
      document.getElementById('muteLabel').textContent = isMuted ? 'Muted' : 'Unmuted';
      
      // Mute/unmute smooth jazz element.
      const jazzAudio = document.getElementById('jazzAudio');
      jazzAudio.muted = isMuted;
      
      // Suspend or resume AudioContext.
      if (isMuted) {
        audioContext.suspend();
      } else {
        audioContext.resume();
      }
    }
    
    // --- Color Palette ---
    // Compute a color based on the x coordinate.
    function getColorFromX(x) {
      const hue = (x / canvas.width) * 360;
      return `hsla(${hue}, 100%, 50%, 0.5)`;
    }
    
    // --- Explosion Simulation ---
    class ExplosionSimulation {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());
        
        // Explosion types
        this.explosionTypes = {
          field: this.fieldExplosion.bind(this),
          blob: this.blobExplosion.bind(this),
          wave: this.waveExplosion.bind(this),
          hybrid: this.hybridExplosion.bind(this)
        };
        
        this.currentExplosionType = 'field';
        this.explosions = [];
      }
      
      resizeCanvas() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
      }
      
      fieldExplosion(x, y) {
        const fieldSize = 100;
        const intensity = 10;
        for (let dx = -fieldSize; dx < fieldSize; dx += 10) {
          for (let dy = -fieldSize; dy < fieldSize; dy += 10) {
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < fieldSize) {
              const falloff = 1 - (distance / fieldSize);
              const particleX = x + dx;
              this.explosions.push({
                x: particleX,
                y: y + dy,
                radius: falloff * intensity,
                color: getColorFromX(particleX),
                life: 1,
                type: 'field'
              });
            }
          }
        }
      }
      
      blobExplosion(x, y) {
        const blobCount = 5;
        const maxRadius = 50;
        for (let i = 0; i < blobCount; i++) {
          const blobX = x + (Math.random() - 0.5) * 50;
          this.explosions.push({
            x: blobX,
            y: y + (Math.random() - 0.5) * 50,
            radius: Math.random() * maxRadius,
            color: getColorFromX(blobX),
            life: 1,
            vx: (Math.random() - 0.5) * 5,
            vy: (Math.random() - 0.5) * 5,
            type: 'blob'
          });
        }
      }
      
      waveExplosion(x, y) {
        const waveCount = 3;
        const maxRadius = 200;
        for (let i = 0; i < waveCount; i++) {
          this.explosions.push({
            x: x,
            y: y,
            radius: 0,
            maxRadius: maxRadius * (i + 1) / waveCount,
            color: getColorFromX(x),
            life: 1,
            growthRate: 5,
            type: 'wave'
          });
        }
      }
      
      hybridExplosion(x, y) {
        this.fieldExplosion(x, y);
        const blobCount = 3;
        const maxRadius = 30;
        for (let i = 0; i < blobCount; i++) {
          const blobX = x + (Math.random() - 0.5) * 100;
          this.explosions.push({
            x: blobX,
            y: y + (Math.random() - 0.5) * 100,
            radius: Math.random() * maxRadius,
            color: getColorFromX(blobX),
            life: 1,
            vx: (Math.random() - 0.5) * 3,
            vy: (Math.random() - 0.5) * 3,
            type: 'hybrid'
          });
        }
        const waveCount = 2;
        const maxWaveRadius = 150;
        for (let i = 0; i < waveCount; i++) {
          this.explosions.push({
            x: x,
            y: y,
            radius: 0,
            maxRadius: maxWaveRadius * (i + 1) / waveCount,
            color: getColorFromX(x),
            life: 1,
            growthRate: 3,
            type: 'hybrid'
          });
        }
      }
      
      render() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.explosions = this.explosions.filter(explosion => {
          switch (explosion.type) {
            case 'field':
              this.ctx.beginPath();
              this.ctx.fillStyle = explosion.color;
              this.ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
              this.ctx.fill();
              explosion.life -= 0.02;
              break;
            case 'blob':
              this.ctx.beginPath();
              this.ctx.fillStyle = explosion.color;
              this.ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
              this.ctx.fill();
              explosion.x += explosion.vx;
              explosion.y += explosion.vy;
              explosion.radius *= 0.95;
              explosion.life -= 0.03;
              break;
            case 'wave':
              this.ctx.beginPath();
              this.ctx.strokeStyle = explosion.color;
              this.ctx.lineWidth = 5;
              this.ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
              this.ctx.stroke();
              explosion.radius += explosion.growthRate;
              explosion.life -= 0.02;
              break;
            case 'hybrid':
              if (explosion.maxRadius) {
                this.ctx.beginPath();
                this.ctx.strokeStyle = explosion.color;
                this.ctx.lineWidth = 3;
                this.ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                this.ctx.stroke();
                explosion.radius += explosion.growthRate;
                explosion.life -= 0.02;
              } else {
                this.ctx.beginPath();
                this.ctx.fillStyle = explosion.color;
                this.ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                this.ctx.fill();
                explosion.x += explosion.vx;
                explosion.y += explosion.vy;
                explosion.radius *= 0.95;
                explosion.life -= 0.03;
              }
              break;
          }
          return explosion.life > 0;
        });
        requestAnimationFrame(this.render.bind(this));
      }
      
      createExplosion(x, y) {
        this.explosionTypes[this.currentExplosionType](x, y);
      }
    }
    
    // --- Audio Setup ---
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    // Default mapping: top (y=0) to 880 Hz, bottom to 220 Hz.
    function getFrequencyFromY(y) {
      const fMax = 880;
      const fMin = 220;
      return fMax - (y / canvas.height) * (fMax - fMin);
    }
    
    // --- Raga Frequency Mapping ---
    // When a raga is selected (other than "none"), use one of its tones.
    function getRagaFrequency() {
      const raga = document.getElementById('ragaSelect').value;
      const scales = {
        Bilawal: [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88],
        Yaman: [293.66, 329.63, 369.99, 392.00, 440.00, 493.88, 554.37],
        Kalyan: [261.63, 293.66, 329.63, 369.99, 392.00, 440.00, 493.88],
        Bhairavi: [261.63, 277.18, 311.13, 349.23, 392.00, 415.30, 466.16]
      };
      if (raga !== 'none' && scales[raga]) {
        const scale = scales[raga];
        return scale[Math.floor(Math.random() * scale.length)];
      }
      return null;
    }
    
    // --- Sound Functions ---
    // Oscillator sound (modified to check raga selection)
    function playOscillatorSound(frequency) {
      if (isMuted) return;
      // Override frequency with a raga tone if one is selected.
      const ragaFreq = getRagaFrequency();
      if (ragaFreq) frequency = ragaFreq;
      
      const oscillator = audioContext.createOscillator();
      oscillator.type = 'sine';
      oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
      
      const gainNode = audioContext.createGain();
      gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.start();
      gainNode.gain.linearRampToValueAtTime(0.0, audioContext.currentTime + 1);
      oscillator.stop(audioContext.currentTime + 1);
    }
    
    // Procedural sound (unused by auto-trigger)
    function playProceduralSound(frequency) {
      if (isMuted) return;
      const gainNode = audioContext.createGain();
      gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
      gainNode.connect(audioContext.destination);
      
      const osc1 = audioContext.createOscillator();
      osc1.type = 'sine';
      osc1.frequency.setValueAtTime(frequency, audioContext.currentTime);
      osc1.connect(gainNode);
      
      const osc2 = audioContext.createOscillator();
      osc2.type = 'square';
      osc2.frequency.setValueAtTime(frequency * 1.5, audioContext.currentTime);
      osc2.connect(gainNode);
      
      // Noise for texture.
      const bufferSize = audioContext.sampleRate;
      const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const data = noiseBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      const noiseSource = audioContext.createBufferSource();
      noiseSource.buffer = noiseBuffer;
      noiseSource.loop = false;
      noiseSource.connect(gainNode);
      
      osc1.start();
      osc2.start();
      noiseSource.start();
      
      osc1.stop(audioContext.currentTime + 0.5);
      osc2.stop(audioContext.currentTime + 0.5);
      noiseSource.stop(audioContext.currentTime + 0.5);
    }
    
    // Custom buffer sound (unused by auto-trigger)
    let audioBuffer = null;
    function loadAudioBuffer(url) {
      fetch(url)
        .then(response => response.arrayBuffer())
        .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
        .then(decodedBuffer => { audioBuffer = decodedBuffer; })
        .catch(e => console.error('Error loading audio buffer', e));
    }
    function playBufferSound(frequency) {
      if (isMuted || !audioBuffer) return;
      const source = audioContext.createBufferSource();
      source.buffer = audioBuffer;
      source.playbackRate.value = frequency / 440;
      source.connect(audioContext.destination);
      source.start();
    }
    
    // Smooth Jazz sound (unused by auto-trigger)
    function playJazzSound() {
      if (isMuted) return;
      const jazzAudio = document.getElementById('jazzAudio');
      if (jazzAudio.paused) {
        jazzAudio.currentTime = 0;
        jazzAudio.play();
      }
    }
    
    // Preload custom sound and jazz audio (update paths as needed)
    loadAudioBuffer('path/to/your/sound.mp3');
    document.getElementById('jazzAudio').muted = isMuted;
    
    // --- Integration ---
    const canvas = document.getElementById('explosionCanvas');
    const simulation = new ExplosionSimulation(canvas);
    
    function setExplosionType(type) {
      simulation.currentExplosionType = type;
    }
    
    // On canvas click: create explosion and play sound based on dropdowns.
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      simulation.createExplosion(x, y);
      // Base frequency computed from y (only used if no raga is selected)
      let frequency = getFrequencyFromY(y);
      
      const soundSelect = document.getElementById('soundSelect').value;
      if (soundSelect === 'oscillator') {
        playOscillatorSound(frequency);
      } else if (soundSelect === 'procedural') {
        playProceduralSound(frequency);
      } else if (soundSelect === 'buffer') {
        playBufferSound(frequency);
      } else if (soundSelect === 'jazz') {
        playJazzSound();
      }
    });
    
    // Auto-trigger function always uses oscillator sound.
    function autoTrigger() {
      const x = Math.random() * canvas.width;
      const y = Math.random() * canvas.height;
      simulation.createExplosion(x, y);
      let frequency = getFrequencyFromY(y);
      playOscillatorSound(frequency);
    }
    
    simulation.render();
  </script>
</body>
</html>
